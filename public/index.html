<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Realtime Canvas</title>
<style>
  :root{
    --bg:#fff9fb; --fg:#222; --border:#e0cfe4; --panel:#ffffffcc; --muted:#888; --accent:#ff99cc;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:800px;margin:20px auto;padding:16px;border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:0 4px 10px rgba(0,0,0,.08)}
  input,button,select{background:#fff;color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font-size:16px}
  input[type=range]{padding:0}
  button{cursor:pointer;transition:background .2s,box-shadow .2s;box-shadow:0 2px 4px rgba(0,0,0,.2);background:linear-gradient(#fff,#e6e6e6)}
  button:active{transform:translateY(1px);box-shadow:inset 0 2px 4px rgba(0,0,0,.2)}
  button:hover{background:var(--accent);color:#fff}
  button.active,.swatch.active,#color.active,.sz.active{box-shadow:0 0 0 3px var(--accent);}
  .sz.active{background:var(--accent);color:#fff}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:.5rem 0}
  #rooms{display:grid;gap:8px;margin-top:8px}
  #stage{position:fixed;inset:0;display:none}
  #grid{position:absolute;inset:0;pointer-events:none}
  #cvs{position:absolute;inset:0;touch-action:none}
  #toolbar{position:fixed;left:8px;top:8px;display:none;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:8px;backdrop-filter:blur(6px);align-items:center;box-shadow:0 4px 10px rgba(0,0,0,.1)}
  #toolbar .group{display:flex;gap:6px;align-items:center}
  #toolbar .dropdown{position:relative}
  #toolbar .dropdown-menu{display:none;position:absolute;top:100%;left:0;flex-direction:column;background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:6px;gap:6px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
  #toolbar .dropdown.open .dropdown-menu{display:flex}
  #toolbar .swatch{width:26px;height:26px;border-radius:6px;border:1px solid var(--border);box-shadow:0 2px 4px rgba(0,0,0,.1)}
  #toolbar small{color:var(--muted)}
  #toolbar.mobile{left:50%;top:auto;bottom:8px;transform:translateX(-50%);flex-wrap:wrap}
  #toolbar.mobile .group{flex-wrap:wrap;justify-content:center}
  #toolbar.mobile button,#toolbar.mobile .swatch,#toolbar.mobile input[type=color]{width:40px;height:40px;font-size:20px;padding:0}
  #toolbar.mobile~.hint{display:none}
  .hint{position:fixed;right:8px;bottom:8px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 8px;font-size:12px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
</style>

<div id="lobby" class="wrap">
  <h2>–ö–æ–º–Ω–∞—Ç—ã</h2>
  <div class="row">
    <input id="room" placeholder="id –∫–æ–º–Ω–∞—Ç—ã" style="flex:1" />
    <button id="create">–°–æ–∑–¥–∞—Ç—å</button>
    <button id="join">–í–æ–π—Ç–∏</button>
  </div>
  <div class="row"><button id="refresh">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button></div>
  <div id="rooms"></div>
</div>

<div id="stage">
  <canvas id="grid"></canvas>
  <canvas id="cvs"></canvas>
</div>

<div id="toolbar">
  <div class="group">
    <button id="tool-draw" class="tool" title="–ö–∏—Å—Ç—å">‚úèÔ∏è</button>
    <button id="tool-erase" class="tool" title="–õ–∞—Å—Ç–∏–∫">ü©π</button>
    <button id="tool-pan" class="tool" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ">üñêÔ∏è</button>
    <div id="more-group" class="dropdown">
      <button id="tool-more" title="–î—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã">‚ãØ</button>
      <div id="more-menu" class="dropdown-menu">
        <button id="tool-select" class="tool" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">üî≤</button>
        <button id="tool-fill" class="tool" title="–ó–∞–ª–∏–≤–∫–∞">ü™£</button>
        <button id="tool-pipette" class="tool" title="–ü–∏–ø–µ—Ç–∫–∞">üß™</button>
        <button id="tool-image" title="–í—Å—Ç–∞–≤–∏—Ç—å PNG">üñºÔ∏è</button>
      </div>
    </div>
  </div>
  <div class="group">
    <small>–¢–æ–ª—â–∏–Ω–∞</small>
    <button class="sz" data-v="2">2</button>
    <button class="sz" data-v="6">6</button>
    <button class="sz" data-v="12">12</button>
    <button class="sz" data-v="24">24</button>
    <input id="size" type="range" min="1" max="40" value="6" title="—Ç–æ–ª—â–∏–Ω–∞" />
  </div>
  <div class="group">
    <small>–¶–≤–µ—Ç</small>
    <button class="col swatch" data-c="#000000" style="background:#000"></button>
    <button class="col swatch" data-c="#ff3b30" style="background:#ff3b30"></button>
    <button class="col swatch" data-c="#34c759" style="background:#34c759"></button>
    <button class="col swatch" data-c="#007aff" style="background:#007aff"></button>
    <input id="color" class="col" type="color" value="#000000" title="—Ü–≤–µ—Ç –∫–∏—Å—Ç–∏"/>
  </div>
  <div class="group">
    <small>–§–æ–Ω</small>
    <input id="bg" type="color" value="#ffffff" title="—Ü–≤–µ—Ç —Ñ–æ–Ω–∞"/>
    <small>–°–µ—Ç–∫–∞</small>
    <input id="gridColor" type="color" value="#f0f0f0" title="—Ü–≤–µ—Ç —Å–µ—Ç–∫–∏"/>
  </div>
  <div class="group">
    <button id="undo" title="–û—Ç–º–µ–Ω–∏—Ç—å">‚Ü∂</button>
    <button id="redo" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å">‚Ü∑</button>
    <button id="export" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG">üñºÔ∏è PNG</button>
    <button id="import" title="–ò–º–ø–æ—Ä—Ç PNG">üì• Import</button>
    <button id="settingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
  </div>
</div>

<input id="imageLoader" type="file" accept="image/png" style="display:none" />

<div class="hint" id="hint">1-5: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ‚Ä¢ 6-9: —Ä–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏ ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ: –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ</div>

<div id="settings" class="wrap" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:100;background:#fff;max-width:400px">
  <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
  <div class="row" style="flex-direction:column;gap:4px">
    <label>–¶–≤–µ—Ç –∫—É—Ä—Å–æ—Ä–∞ <input id="cursorColorInput" type="color" value="#007aff"/></label>
    <label>–ö–∏—Å—Ç—å <input class="hk" data-action="draw" value="1" size="2"/></label>
    <label>–õ–∞—Å—Ç–∏–∫ <input class="hk" data-action="erase" value="2" size="2"/></label>
    <label>–í—ã–¥–µ–ª–µ–Ω–∏–µ <input class="hk" data-action="select" value="3" size="2"/></label>
    <label>–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ <input class="hk" data-action="pan" value="4" size="2"/></label>
    <label>–ó–∞–ª–∏–≤–∫–∞ <input class="hk" data-action="fill" value="5" size="2"/></label>
    <label>–†–∞–∑–º–µ—Ä 2 <input class="hk" data-action="size2" value="6" size="2"/></label>
    <label>–†–∞–∑–º–µ—Ä 6 <input class="hk" data-action="size6" value="7" size="2"/></label>
    <label>–†–∞–∑–º–µ—Ä 12 <input class="hk" data-action="size12" value="8" size="2"/></label>
    <label>–†–∞–∑–º–µ—Ä 24 <input class="hk" data-action="size24" value="9" size="2"/></label>
  </div>
  <div class="row"><button id="settingsClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<script type="module" src="embed-png.js"></script>
<script src="net-webrtc.js"></script>
<script>
// ===== util =====
const $ = s=>document.querySelector(s);
const $$ = s=>Array.from(document.querySelectorAll(s));
const genId = ()=> `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;

// ===== canvases & camera =====
const stage = $('#stage');
const grid = $('#grid'), gtx = grid.getContext('2d');
const cvs = $('#cvs'), ctx = cvs.getContext('2d');
let DPR = Math.max(1, devicePixelRatio||1);
let camera = { x:0, y:0, scale:1 };

function resize(){
  const w = innerWidth, h = innerHeight; DPR = Math.max(1, devicePixelRatio||1);
  [grid,cvs].forEach(cn=>{ cn.width=w*DPR; cn.height=h*DPR; cn.style.width=w+'px'; cn.style.height=h+'px'; });
  ctx.setTransform(DPR,0,0,DPR,0,0); gtx.setTransform(DPR,0,0,DPR,0,0);
  drawGrid(); requestRender();
}
addEventListener('resize', resize, {passive:true});

let gridColor = '#f0f0f0';
function drawGrid(){
  const w=grid.width/DPR, h=grid.height/DPR;
  gtx.clearRect(0,0,w,h);
  const step = 200*camera.scale;
  if (step>24){
    gtx.strokeStyle = gridColor;
    gtx.lineWidth = 1;
    const sx = -((camera.x*camera.scale)%step), sy = -((camera.y*camera.scale)%step);
    gtx.beginPath();
    for(let x=sx;x<w;x+=step){ gtx.moveTo(x,0); gtx.lineTo(x,h); }
    for(let y=sy;y<h;y+=step){ gtx.moveTo(0,y); gtx.lineTo(w,y); }
    gtx.stroke();
  }
}

// ===== state =====
let roomId=null, meId=null;
let mode='draw';
let brush = { color:'#000000', size:6 };
let bgColor = '#ffffff';
let selection=null, selOp=null, selectionPreview=null;
let cursorColor='#007aff';
const defaultHotkeys={draw:'1',erase:'2',select:'3',pan:'4',fill:'5',size2:'6',size6:'7',size12:'8',size24:'9'};
let hotkeys={...defaultHotkeys};
function loadSettings(){ try{ const s=JSON.parse(localStorage.getItem('settings')); if(s){ if(s.hotkeys) Object.assign(hotkeys,s.hotkeys); if(s.cursorColor) cursorColor=s.cursorColor; } }catch{} }
function saveSettings(){ try{ localStorage.setItem('settings',JSON.stringify({hotkeys,cursorColor})); }catch{} }
loadSettings();
function renderHint(){ $('#hint').textContent=`–ö–∏—Å—Ç—å: ${hotkeys.draw} ‚Ä¢ –õ–∞—Å—Ç–∏–∫: ${hotkeys.erase} ‚Ä¢ –í—ã–¥–µ–ª–µ–Ω–∏–µ: ${hotkeys.select} ‚Ä¢ –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ: ${hotkeys.pan} ‚Ä¢ –ó–∞–ª–∏–≤–∫–∞: ${hotkeys.fill} ‚Ä¢ –†–∞–∑–º–µ—Ä: ${hotkeys.size2}/${hotkeys.size6}/${hotkeys.size12}/${hotkeys.size24} ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ: –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ`; }
renderHint();

const strokes = new Map(); // id-> {id,by,mode,...}
const cache = new Map();   // –ø–æ–ª–Ω—ã–π —à—Ç—Ä–∏—Ö (–¥–ª—è redo/—Ä–µ—Å–∏–Ω–∫–∞)
const myStack = [];        // ids –º–æ–∏—Ö —à—Ç—Ä–∏—Ö–æ–≤ (–¥–ª—è undo)
const redoStack = [];      // ids –¥–ª—è redo

const patternCanvas=document.createElement('canvas'); patternCanvas.width=8; patternCanvas.height=8; const ptx=patternCanvas.getContext('2d');
let selPattern=null; function updateSelPattern(){ ptx.clearRect(0,0,8,8); ptx.strokeStyle=cursorColor; ptx.lineWidth=1; ptx.beginPath(); ptx.moveTo(0,0); ptx.lineTo(8,8); ptx.moveTo(0,8); ptx.lineTo(8,0); ptx.stroke(); selPattern=ctx.createPattern(patternCanvas,'repeat'); }
updateSelPattern();

// ===== UI wiring =====
const toolbar = $('#toolbar');
const toolButtons = $$('.tool');
const isMobile = matchMedia('(pointer:coarse)').matches;
if(isMobile) toolbar.classList.add('mobile');
function setTool(t){ mode=t; toolButtons.forEach(btn=>btn.classList.toggle('active', btn.id==='tool-'+t)); }
$('#tool-draw').onclick = ()=> setTool('draw');
$('#tool-erase').onclick = ()=> setTool('erase');
$('#tool-pan').onclick = ()=> setTool('pan');
$('#tool-select').onclick = ()=> setTool('select');
$('#tool-fill').onclick = ()=> setTool('fill');
$('#tool-pipette').onclick = ()=> setTool('pipette');

const moreGroup = $('#more-group');
$('#tool-more').onclick = e=>{ e.stopPropagation(); moreGroup.classList.toggle('open'); };
document.addEventListener('click', e=>{ if(!moreGroup.contains(e.target)) moreGroup.classList.remove('open'); });
$('#more-menu').onclick = ()=> moreGroup.classList.remove('open');

const imageLoader = $('#imageLoader');
$('#tool-image').onclick = ()=> imageLoader.click();

const sizeButtons = $$('.sz');
function setSize(v){ brush.size=v; $('#size').value=v; sizeButtons.forEach(b=>b.classList.toggle('active', +b.dataset.v===v)); }
$('#size').oninput = e=> setSize(+e.target.value);
sizeButtons.forEach(b=> b.onclick = ()=> setSize(+b.dataset.v));

const colorInputs = $$('.col');
function setColor(c, el){ brush.color=c; $('#color').value=c; colorInputs.forEach(b=>b.classList.toggle('active', b===el)); }
$('#color').oninput = e=> setColor(e.target.value, $('#color'));
colorInputs.forEach(b=> b.onclick = ()=> setColor(b.dataset.c, b));
setTool(mode);
setSize(brush.size);
setColor(brush.color, $('#color'));
$('#bg').oninput = e=> { bgColor=e.target.value; requestRender(); debounceSave(); };
$('#gridColor').oninput = e=> { gridColor=e.target.value; drawGrid(); };
$('#undo').onclick = undo; $('#redo').onclick = redo;
$('#export').onclick = exportPNG;
$('#import').onclick = ()=> imageLoader.click();
$('#settingsBtn').onclick = ()=>{ $('#settings').style.display='block'; $$('.hk').forEach(inp=> inp.value=hotkeys[inp.dataset.action]||''); $('#cursorColorInput').value=cursorColor; };
$('#settingsClose').onclick = ()=>{ $('#settings').style.display='none'; saveSettings(); renderHint(); };
$$('.hk').forEach(inp=>{ inp.oninput=()=>{ hotkeys[inp.dataset.action]=inp.value; saveSettings(); renderHint(); }; });
$('#cursorColorInput').oninput = e=>{ cursorColor=e.target.value; updateSelPattern(); saveSettings(); requestRender(); };
imageLoader.onchange = async e=>{
  const file=e.target.files[0];
  if(file) await importPNG(file);
  e.target.value='';
};
document.addEventListener('paste', e=>{
  const item=[...(e.clipboardData?.items||[])].find(it=>it.type==='image/png');
  if(item){ const file=item.getAsFile(); if(file) importPNG(file); }
});
cvs.addEventListener('dragover', e=>{ e.preventDefault(); });
cvs.addEventListener('drop', e=>{
  e.preventDefault();
  const file=e.dataTransfer.files[0];
  if(file) importPNG(file);
});

document.addEventListener('keydown',e=>{
  if(e.target.tagName==='INPUT') return;
  const k=e.key;
  if(k===hotkeys.draw) setTool('draw');
  else if(k===hotkeys.erase) setTool('erase');
  else if(k===hotkeys.select) setTool('select');
  else if(k===hotkeys.pan) setTool('pan');
  else if(k===hotkeys.fill) setTool('fill');
  else if(k===hotkeys.size2) setSize(2);
  else if(k===hotkeys.size6) setSize(6);
  else if(k===hotkeys.size12) setSize(12);
  else if(k===hotkeys.size24) setSize(24);
});

// ===== lobby / rooms =====
async function getSignalURL(){ const r = await fetch('config.json', {cache:'no-store'}); const j = await r.json(); return j.SIGNAL_URL; }
async function fetchRooms(){
  try{
    const url = await getSignalURL();
    return await new Promise(res=>{
      const ws = new WebSocket(url);
      const t = setTimeout(()=>{ try{ws.close()}catch{}; res([]); }, 2000);
      ws.onopen = ()=> ws.send(JSON.stringify({type:'list'}));
      ws.onmessage = e=>{ const m=JSON.parse(e.data); if(m.type==='rooms'){ clearTimeout(t); ws.close(); res(m.rooms||[]); } };
      ws.onerror = ()=>{ clearTimeout(t); res([]); };
    });
  }catch{ return []; }
}

async function renderRooms(){
  const list = await fetchRooms();
  const holder = $('#rooms'); holder.innerHTML='';
  list.forEach(r=>{
    const b=document.createElement('button'); b.textContent=`${r.id} (${r.users})`; b.onclick=()=> $('#room').value=r.id; holder.appendChild(b);
  });
}
$('#refresh').onclick = renderRooms; renderRooms();

$('#create').onclick = async ()=>{
  const rid = ($('#room').value.trim() || `room-${Math.random().toString(36).slice(2,6)}`);
  $('#room').value = rid;
  // —è –≤–µ—à—É —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ —è–≤–Ω—ã–π –≤—ã–∑–æ–≤ create (—Ä–µ–µ—Å—Ç—Ä –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–µ)
  const url = await getSignalURL();
  const ws = new WebSocket(url);
  ws.onopen = ()=> ws.send(JSON.stringify({type:'create', roomId: rid}));
  ws.onmessage = e=>{ const m=JSON.parse(e.data); if(m.type==='created'){ alert('–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞'); ws.close(); renderRooms(); } };
};

$('#join').onclick = ()=>{
  roomId = ($('#room').value.trim() || 'public-room');
  lobbyToStage();
  Net.connect(roomId,{
    onJoined: ({me, peers})=>{
      meId = me;
      // –∑–∞–ø—Ä–æ—Å–∏–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–π —Å–Ω–∞–ø—à–æ—Ç (–µ—Å–ª–∏ –µ—Å—Ç—å)
      Net.requestState();
      // –µ—Å–ª–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ —Å–µ–∫—É–Ω–¥—ã —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –ø—Ä–∏—à–ª–æ ‚Äî –ø–æ–¥–Ω–∏–º–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ
      setTimeout(()=>{ if (strokes.size===0) loadLocal(); }, 1000);
    },
    onPeerOpen: (peerId)=>{
      // —É —Ç–æ–ª—å–∫–æ —á—Ç–æ –æ—Ç–∫—Ä—ã–≤—à–µ–≥–æ—Å—è –ø–∏—Ä–∞ –ø–æ–ø—Ä–æ—Å–∏–º —Å–Ω–∞–ø—à–æ—Ç
      Net.sendReliableTo(peerId, { type:'state_req' });
    },
    onState: (state)=>{ if(state) mergeState(state); },
    onMsg: handleMsg,
    onCursor: ({id,x,y,drawing})=>{ cursors.set(id,{x,y,drawing,ts:Date.now()}); requestRender(); }
  });
};

function lobbyToStage(){
  document.getElementById('lobby').style.display='none';
  stage.style.display='block';
  document.getElementById('toolbar').style.display='flex';
  resize();
}

// ===== drawing =====
let isDown=false, lastMove=null, current=null;
const cursors = new Map();
const touches = new Map();
let pinchStart=null;

function getTouchState(){
  const pts=[...touches.values()];
  const center={x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
  const dist=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
  return {center, dist};
}

cvs.addEventListener('pointerdown', (e)=>{
  cvs.setPointerCapture(e.pointerId);
  if(e.pointerType==='touch'){
    touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(touches.size===2){
      pinchStart={camera:{...camera},...getTouchState()};
      if(current){ strokes.delete(current.id); cache.delete(current.id); myStack.pop(); enqueue({type:'del',id:current.id}); requestRender(); }
      isDown=false; current=null;
      return;
    }
  }
  isDown=true;
  if(mode==='pipette'){
    const w=toWorld(e);
    const x=Math.round((w.x-camera.x)*camera.scale*DPR);
    const y=Math.round((w.y-camera.y)*camera.scale*DPR);
    const d=ctx.getImageData(x,y,1,1).data;
    const c="#"+((1<<24)+(d[0]<<16)+(d[1]<<8)+d[2]).toString(16).slice(1);
    setColor(c,$('#color'));
    setTool('draw');
    isDown=false;
    return;
  }
  if (e.button===1 || mode==='pan'){ lastMove={x:e.clientX,y:e.clientY}; return; }
  const w=toWorld(e);
  if (mode==='fill'){
    const id=genId();
    const s={id,by:meId,mode:'fill',color:brush.color,size:0,points:[w]};
    strokes.set(id,s); cache.set(id,s); myStack.push(id); redoStack.length=0;
    enqueue({type:'fill',id,by:meId,color:brush.color,x:w.x,y:w.y});
    requestRender(); debounceSave(); return;
  }
  if (mode==='select'){
    if(selection){ const r=selection.rect; const hit=pointInRect(w,r); const corner=hitCorner(w,r,10/camera.scale); if(corner){ selOp={type:'resize',corner,start:w,rect:{...r},orig:new Map(),path:selection.path.map(p=>({...p}))}; for(const id of selection.ids) selOp.orig.set(id,cloneStroke(strokes.get(id))); } else if(hit){ selOp={type:'move',start:w,rect:{...r},orig:new Map(),path:selection.path.map(p=>({...p}))}; for(const id of selection.ids) selOp.orig.set(id,cloneStroke(strokes.get(id))); } else { selection=null; selOp={type:'select',points:[w]}; } }
    else { selOp={type:'select',points:[w]}; }
    selectionPreview=null; return;
  }
  current = { id: genId(), by: meId, mode, color:(mode==='erase'?'#000000':brush.color), size:brush.size, points:[w] };
  strokes.set(current.id, current); cache.set(current.id, current); myStack.push(current.id); redoStack.length=0;
  enqueue({ type:'stroke_pts', id: current.id, by: meId, mode: current.mode, color: current.color, size: current.size, points:[w] });
  requestRender();
});

cvs.addEventListener('pointermove', (e)=>{
  if(e.pointerType==='touch' && touches.has(e.pointerId)){
    touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(touches.size===2 && pinchStart){
      const {center,dist}=getTouchState();
      const before=screenToWorld(pinchStart.center.x,pinchStart.center.y,pinchStart.camera);
      camera.scale=clamp(pinchStart.camera.scale*(dist/pinchStart.dist),0.1,8);
      const after=screenToWorld(center.x,center.y);
      camera.x+=before.x-after.x; camera.y+=before.y-after.y;
      drawGrid(); requestRender();
      return;
    }
    if(touches.size>1) return;
  }
  const w=toWorld(e);
  if (e.buttons===4 || (isDown && (e.button===1 || mode==='pan'))){
    if (lastMove){ camera.x -= (e.clientX-lastMove.x)/camera.scale; camera.y -= (e.clientY-lastMove.y)/camera.scale; drawGrid(); requestRender(); }
    lastMove={x:e.clientX,y:e.clientY}; return;
  }
  if(mode==='select' && isDown && selOp){
    if(selOp.type==='select'){ selOp.points.push(w); selectionPreview=selOp.points.slice(); }
    if(selOp.type==='move'){
      const dx=w.x-selOp.start.x, dy=w.y-selOp.start.y;
      selection.rect={x:selOp.rect.x+dx,y:selOp.rect.y+dy,w:selOp.rect.w,h:selOp.rect.h};
      selection.path=selOp.path.map(p=>({x:p.x+dx,y:p.y+dy}));
      for(const id of selection.ids){
        const o=selOp.orig.get(id); const s=strokes.get(id);
        if(s.mode==='fill'){ s.points[0].x=o.points[0].x+dx; s.points[0].y=o.points[0].y+dy; }
        else if(s.mode==='image'){ s.x=o.x+dx; s.y=o.y+dy; }
        else{ s.points=o.points.map(p=>({x:p.x+dx,y:p.y+dy})); }
      }
    }
    if(selOp.type==='resize'){
      const r=selOp.rect; let x1=r.x, y1=r.y, x2=r.x+r.w, y2=r.y+r.h;
      if(selOp.corner.includes('l')) x1=w.x;
      if(selOp.corner.includes('r')) x2=w.x;
      if(selOp.corner.includes('t')) y1=w.y;
      if(selOp.corner.includes('b')) y2=w.y;
      const rect={x:Math.min(x1,x2),y:Math.min(y1,y2),w:Math.abs(x2-x1),h:Math.abs(y2-y1)};
      selection.rect=rect;
      const sx=rect.w/r.w, sy=rect.h/r.h; const ox=r.x, oy=r.y;
      selection.path=selOp.path.map(p=>({x:rect.x+(p.x-ox)*sx,y:rect.y+(p.y-oy)*sy}));
      for(const id of selection.ids){
        const o=selOp.orig.get(id); const s=strokes.get(id);
        if(s.mode==='fill'){
          const p=o.points[0]; s.points[0].x=rect.x+(p.x-ox)*sx; s.points[0].y=rect.y+(p.y-oy)*sy;
        } else if(s.mode==='image'){
          s.x=rect.x+(o.x-ox)*sx; s.y=rect.y+(o.y-oy)*sy; s.w=o.w*sx; s.h=o.h*sy;
        } else {
          s.points=o.points.map(p=>({x:rect.x+(p.x-ox)*sx,y:rect.y+(p.y-oy)*sy}));
        }
      }
    }
    requestRender(); Net.sendCursor({x:w.x,y:w.y,drawing:false}); return;
  }
  if(isDown && current && (mode==='draw' || mode==='erase')){
    current.points.push(w);
    enqueue({ type:'stroke_pts', id: current.id, by: meId, mode: current.mode, color: current.color, size: current.size, points:[w] });
    requestRender();
  }
  Net.sendCursor({ x:w.x, y:w.y, drawing:isDown });
});

cvs.addEventListener('pointerup', (e)=>{
  if(e.pointerType==='touch'){
    touches.delete(e.pointerId);
    if(pinchStart){
      if(touches.size<2) pinchStart=null;
      isDown=false; current=null; lastMove=null;
      return;
    }
  }
  isDown=false; lastMove=null;
  if(mode==='select' && selOp){
    if(selOp.type==='select' && selOp.points){
      const poly=selOp.points; const rect=bboxOfPoints(poly); selection={ids:[],path:poly,rect};
      for(const [id,s] of strokes){ if(strokeIntersectsPoly(s,poly)) selection.ids.push(id); }
      if(selection.ids.length===0) selection=null;
    } else if(selOp.type==='move' || selOp.type==='resize'){
      if(selection) for(const id of selection.ids){ const s=strokes.get(id); Net.sendReliable({type:'del',id}); const payload={...s}; Net.sendReliable({type:'add',stroke:payload}); }
    }
    selOp=null; selectionPreview=null; requestRender(); debounceSave(); current=null; return;
  }
  current=null;
});

cvs.addEventListener('pointercancel', e=>{ touches.delete(e.pointerId); pinchStart=null; });

// –∑—É–º/–ø–∞–Ω –∫–æ–ª–µ—Å–æ–º
cvs.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const mouse = { clientX:e.clientX, clientY:e.clientY };
  if (e.shiftKey){ camera.x -= e.deltaX / camera.scale; camera.y -= e.deltaY / camera.scale; drawGrid(); requestRender(); return; }
  const before = toWorld(mouse);
  const k = Math.pow(1.0015, -e.deltaY);
  camera.scale = clamp(camera.scale * k, 0.1, 8);
  const after = toWorld(mouse);
  camera.x += before.x - after.x; camera.y += before.y - after.y;
  drawGrid(); requestRender();
},{passive:false});

addEventListener('keydown', e=>{
  if(e.key==='Delete' && selection){
    for(const id of selection.ids){ strokes.delete(id); Net.sendReliable({type:'del',id}); }
    selection=null; requestRender(); debounceSave();
  }
});

function toWorld(e){ return { x: e.clientX/camera.scale + camera.x, y: e.clientY/camera.scale + camera.y }; }
function screenToWorld(x,y,cam=camera){ return { x: x/cam.scale + cam.x, y: y/cam.scale + cam.y }; }
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function rectFromPoints(a,b){ return {x:Math.min(a.x,b.x), y:Math.min(a.y,b.y), w:Math.abs(a.x-b.x), h:Math.abs(a.y-b.y)}; }
function pointInRect(p,r){ return p.x>=r.x && p.y>=r.y && p.x<=r.x+r.w && p.y<=r.y+r.h; }
function rectsIntersect(a,b){ return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y); }
function hitCorner(p,r,t){
  const x1=r.x, y1=r.y, x2=r.x+r.w, y2=r.y+r.h;
  if(Math.abs(p.x-x1)<=t && Math.abs(p.y-y1)<=t) return 'tl';
  if(Math.abs(p.x-x2)<=t && Math.abs(p.y-y1)<=t) return 'tr';
  if(Math.abs(p.x-x1)<=t && Math.abs(p.y-y2)<=t) return 'bl';
  if(Math.abs(p.x-x2)<=t && Math.abs(p.y-y2)<=t) return 'br';
  return null;
}
function bboxOfPoints(pts){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const p of pts){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {x:minX,y:minY,w:maxX-minX,h:maxY-minY}; }
function pointInPoly(p,poly){ let inside=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){ const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y; const intersect=((yi>p.y)!=(yj>p.y)) && (p.x<(xj-xi)*(p.y-yi)/(yj-yi)+xi); if(intersect) inside=!inside; } return inside; }
function strokeIntersectsPoly(s,poly){ if(s.mode==='image'){ const pts=[{x:s.x,y:s.y},{x:s.x+s.w,y:s.y},{x:s.x,y:s.y+s.h},{x:s.x+s.w,y:s.y+s.h}]; return pts.some(pt=>pointInPoly(pt,poly)); } if(s.mode==='fill'){ return pointInPoly(s.points[0],poly); } return s.points.some(pt=>pointInPoly(pt,poly)); }
function cloneStroke(s){ return s.mode==='image'?{...s}:{...s,points:s.points.map(p=>({...p}))}; }
function bboxOfStroke(s){
  if(s.mode==='fill'){ const p=s.points[0]; return {x:p.x-1,y:p.y-1,w:2,h:2}; }
  if(s.mode==='image'){ return {x:s.x,y:s.y,w:s.w,h:s.h}; }
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const p of s.points){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return {x:minX,y:minY,w:maxX-minX,h:maxY-minY};
}
function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function applyFillStroke(s){
  const w=cvs.width, h=cvs.height;
  const x=Math.round((s.points[0].x-camera.x)*camera.scale*DPR);
  const y=Math.round((s.points[0].y-camera.y)*camera.scale*DPR);
  if(x<0||y<0||x>=w||y>=h) return;
  const img=ctx.getImageData(0,0,w,h);
  const data=img.data;
  const idx=(y*w+x)*4;
  const target=[data[idx],data[idx+1],data[idx+2],data[idx+3]];
  const fill=hexToRgb(s.color);
  if(target[0]===fill[0] && target[1]===fill[1] && target[2]===fill[2] && target[3]===255) return;
  const stack=[[x,y]];
  const match=i=>data[i]===target[0]&&data[i+1]===target[1]&&data[i+2]===target[2]&&data[i+3]===target[3];
  while(stack.length){
    const [cx,cy]=stack.pop();
    const i=(cy*w+cx)*4;
    if(!match(i)) continue;
    data[i]=fill[0]; data[i+1]=fill[1]; data[i+2]=fill[2]; data[i+3]=255;
    if(cx>0) stack.push([cx-1,cy]);
    if(cx<w-1) stack.push([cx+1,cy]);
    if(cy>0) stack.push([cx,cy-1]);
    if(cy<h-1) stack.push([cx,cy+1]);
  }
  ctx.putImageData(img,0,0);
}

function loadImageForStroke(s){
  const img=new Image();
  img.onload=requestRender;
  img.src=s.data;
  Object.defineProperty(s,'_img',{value:img,enumerable:false});
}

// –±–∞—Ç—á–∏–Ω–≥ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
const buffer=[]; let flushTimer=null;
function enqueue(op){
  buffer.push(op);
  if(!flushTimer){ flushTimer=setTimeout(()=>{ Net.sendReliable({ type:'batch', ops: buffer.splice(0, buffer.length) }); flushTimer=null; }, 20); }
}

// –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä
let rerender=false; function requestRender(){ rerender=true; }
function loop(){ if(rerender){ draw(); rerender=false; } requestAnimationFrame(loop); } loop();
function draw(){
  const w=cvs.width/DPR, h=cvs.height/DPR;
  ctx.clearRect(0,0,w,h); ctx.fillStyle=bgColor; ctx.fillRect(0,0,w,h);
  for(const s of strokes.values()){
    if(s.mode==='fill'){ applyFillStroke(s); continue; }
    if(s.mode==='image'){ if(s._img) ctx.drawImage(s._img,(s.x-camera.x)*camera.scale,(s.y-camera.y)*camera.scale,s.w*camera.scale,s.h*camera.scale); continue; }
    ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.globalCompositeOperation = (s.mode==='erase')?'destination-out':'source-over';
    ctx.strokeStyle=s.color; ctx.lineWidth=s.size*camera.scale;
    ctx.beginPath(); s.points.forEach((p,i)=>{ const x=(p.x-camera.x)*camera.scale, y=(p.y-camera.y)*camera.scale; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke(); ctx.restore();
  }
  if(selection) drawSel(selection.path, selection.rect, true);
  if(selectionPreview) drawSel(selectionPreview, bboxOfPoints(selectionPreview), false);
  if(selection || selectionPreview) requestRender();
  // –∫—É—Ä—Å–æ—Ä—ã
  const now=Date.now();
  for(const [id,c] of cursors){ if(now-c.ts>3000) continue; const x=(c.x-camera.x)*camera.scale, y=(c.y-camera.y)*camera.scale; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle=cursorColor; ctx.fill(); }
}

function drawSel(path, rect, handles){
  ctx.save();
  ctx.beginPath();
  path.forEach((p,i)=>{ const x=(p.x-camera.x)*camera.scale, y=(p.y-camera.y)*camera.scale; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
  ctx.closePath();
  ctx.save();
  const t=(Date.now()/150)%8; ctx.translate(-t,-t); ctx.fillStyle=selPattern; ctx.fill(); ctx.restore();
  ctx.strokeStyle=cursorColor; ctx.setLineDash([8,4]); ctx.stroke(); ctx.setLineDash([]);
  if(handles){ const x=(rect.x-camera.x)*camera.scale, y=(rect.y-camera.y)*camera.scale, w=rect.w*camera.scale, h=rect.h*camera.scale; const hs=6; const corners=[[x,y],[x+w,y],[x,y+h],[x+w,y+h]]; ctx.fillStyle='#fff'; ctx.strokeStyle=cursorColor; for(const [cx,cy] of corners){ ctx.beginPath(); ctx.rect(cx-hs/2,cy-hs/2,hs,hs); ctx.fill(); ctx.stroke(); } }
  ctx.restore();
}

// —Å–µ—Ç–µ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
function handleMsg(op){
  if(op.type==='batch'){ for(const a of op.ops) handleMsg(a); return; }
  if(op.type==='stroke_pts'){
    let s = strokes.get(op.id);
    if(!s){ s = { id:op.id, by:op.by, mode:op.mode, color:op.color, size:op.size, points:[] }; strokes.set(op.id, s); cache.set(op.id, s); }
    for(const p of op.points) s.points.push(p);
    requestRender(); debounceSave(); return;
  }
  if(op.type==='fill'){
    const s={id:op.id,by:op.by,mode:'fill',color:op.color,size:0,points:[{x:op.x,y:op.y}]};
    strokes.set(op.id,s); cache.set(op.id,s); requestRender(); debounceSave(); return;
  }
  if(op.type==='del'){ strokes.delete(op.id); requestRender(); debounceSave(); return; }
  if(op.type==='add'){ const s = op.stroke; if(s.mode==='image') loadImageForStroke(s); strokes.set(s.id, s); cache.set(s.id, s); requestRender(); debounceSave(); return; }
  if(op.type==='state_req'){ Net.sendReliableTo(op.id, { type:'state_full', state: serializeState() }); return; }
  if(op.type==='state_full'){
    if(op.state) mergeState(op.state); return;
  }
}

function serializeState(){ return { bg: bgColor, strokes: Array.from(strokes.values()) }; }
function mergeState(state, opt={}){
  const added=[]; const setBg = opt.setBg!==false;
  try{
    if (setBg && state.bg) bgColor = state.bg;
    if (Array.isArray(state.strokes)){
      for(const s of state.strokes){
        const ex = strokes.get(s.id);
        if(!ex || (ex.points && s.points && s.points.length>ex.points.length)){
          if(s.mode==='image') loadImageForStroke(s);
          strokes.set(s.id, s); cache.set(s.id, s); added.push(s.id);
        }
      }
    }
    requestRender(); debounceSave();
  }catch{}
  return added;
}

// undo/redo
function undo(){ const id = myStack.pop(); if(!id) return; Net.sendReliable({type:'del', id}); strokes.delete(id); redoStack.push(id); requestRender(); debounceSave(); }
function redo(){ const id = redoStack.pop(); if(!id) return; const s = cache.get(id); if(!s) return; strokes.set(id, s); const payload={...s}; Net.sendReliable({type:'add', stroke:payload}); myStack.push(id); requestRender(); debounceSave(); }

// PNG —ç–∫—Å–ø–æ—Ä—Ç
async function exportPNG(){
  if (strokes.size===0){ alert('–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å'); return; }
  const blob=await exportEmbeddedPNG();
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='canvas.png';
  a.click();
}

// –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ü–∏—è + —Å–µ—Ä–≤–µ—Ä–Ω–∞—è
function saveLocal(){ try{ localStorage.setItem('room:'+roomId, JSON.stringify(serializeState())); }catch{} }
function loadLocal(){ try{ const j=localStorage.getItem('room:'+roomId); if(j){ const s=JSON.parse(j); if(s) mergeState(s); } }catch{} }
let saveTimer=null; function debounceSave(){ if(saveTimer) return; saveTimer=setTimeout(()=>{ saveTimer=null; saveLocal(); Net.saveState(serializeState()); }, 300); }
</script>
