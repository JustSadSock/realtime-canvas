<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Realtime Canvas</title>
<style>
  html,body{margin:0;height:100%;background:#0e0f12;color:#eaeaea;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:740px;margin:20px auto;padding:16px;border:1px solid #2a2f3a;border-radius:12px;background:#171a1f}
  input,button{background:#10141b;color:#eaeaea;border:1px solid #2f3542;border-radius:10px;padding:10px 12px;font-size:16px}
  button{cursor:pointer} button:active{transform:translateY(1px)}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:.5rem 0}
  #rooms{display:grid;gap:8px;margin-top:8px}
  #cvs{display:none;position:fixed;inset:0;touch-action:none;background:#0b0c0f}
  #toolbar{position:fixed;left:8px;top:8px;display:none;gap:8px;background:#171a1fcc;border:1px solid #2a2f3a;border-radius:12px;padding:8px;backdrop-filter:blur(6px)}
  label{font-size:12px;opacity:.85}
</style>

<div id="lobby" class="wrap">
  <h2>–ö–æ–º–Ω–∞—Ç—ã</h2>
  <div class="row">
    <input id="room" placeholder="id –∫–æ–º–Ω–∞—Ç—ã" style="flex:1">
    <label><input type="checkbox" id="asHost" checked> —è ‚Äî —Ö–æ—Å—Ç (—Å–æ–∑–≤–∞–Ω–∏–≤–∞—é—Å—å –ø–µ—Ä–≤—ã–º)</label>
    <button id="join">–í–æ–π—Ç–∏</button>
  </div>
  <div class="row"><button id="refresh">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button></div>
  <div id="rooms"></div>
  <p style="opacity:.7;font-size:14px;margin-top:12px">
    –ü–æ–¥—Å–∫–∞–∑–∫–∞: –ø–æ—Å–ª–µ –¥–µ–ø–ª–æ—è –Ω–∞ Netlify –Ω–µ –∑–∞–±—É–¥—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å <code>wss://...—Ç–≤–æ–π_—Ç—É–Ω–Ω–µ–ª—å</code> –≤ <code>config.json</code>.
  </p>
</div>

<canvas id="cvs"></canvas>
<div id="toolbar">
  <button id="draw">‚úèÔ∏è</button>
  <button id="erase">ü©π</button>
  <input id="color" type="color" value="#ffffff" title="—Ü–≤–µ—Ç">
  <input id="size" type="range" min="1" max="40" value="6" title="—Ç–æ–ª—â–∏–Ω–∞">
  <button id="move">üñêÔ∏è</button>
</div>

<!-- —Å–µ—Ç–µ–≤–æ–π –º–æ–¥—É–ª—å -->
<script src="net-webrtc.js"></script>
<script>
const lobby = document.getElementById('lobby');
const roomsEl = document.getElementById('rooms');
const cvs = document.getElementById('cvs'), ctx = cvs.getContext('2d');
const toolbar = document.getElementById('toolbar');
let DPR = Math.max(1, devicePixelRatio||1), camera={x:0,y:0,scale:1};

let mode='draw', brush={color:'#ffffff', size:6};
document.getElementById('draw').onclick=()=>mode='draw';
document.getElementById('erase').onclick=()=>mode='erase';
document.getElementById('move').onclick=()=>mode='move';
document.getElementById('color').oninput=e=>brush.color=e.target.value;
document.getElementById('size').oninput=e=>brush.size=+e.target.value;

async function renderRooms(){
  const list = await Net.rooms().catch(()=>[]);
  roomsEl.innerHTML='';
  list.forEach(r=>{
    const b=document.createElement('button');
    b.textContent=`${r.id} (${r.users})`;
    b.onclick=()=> document.getElementById('room').value=r.id;
    roomsEl.appendChild(b);
  });
}
document.getElementById('refresh').onclick=renderRooms; renderRooms();

document.getElementById('join').onclick = ()=>{
  const rid = document.getElementById('room').value.trim() || 'public-room';
  Net.setHost(document.getElementById('asHost').checked);
  Net.connect(rid,{
    onMsg: (op)=> applyOp(op),
    onCursor: ({id,x,y,drawing})=> { cursors.set(id,{x,y,drawing,ts:Date.now()}); }
  });
  lobby.style.display='none'; cvs.style.display='block'; toolbar.style.display='flex';
  resize();
};

// ====== —Ä–∏—Å–æ–≤–∞–ª–∫–∞ ======
let strokes=[], cursors=new Map();
function resize(){ const w=innerWidth,h=innerHeight; DPR=Math.max(1,devicePixelRatio||1);
  cvs.width=w*DPR; cvs.height=h*DPR; cvs.style.width=w+'px'; cvs.style.height=h+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); requestRender(); }
addEventListener('resize', resize,{passive:true});

function toWorld(e){ return { x: e.clientX/camera.scale + camera.x, y: e.clientY/camera.scale + camera.y }; }
let rerender=false; function requestRender(){ rerender=true; }
function loop(){ if (rerender){ draw(); rerender=false; } requestAnimationFrame(loop); } loop();

function draw(){
  const w=cvs.width/DPR, h=cvs.height/DPR;
  ctx.clearRect(0,0,w,h);

  // —Å–µ—Ç–∫–∞
  const step = 200*camera.scale;
  if (step>24){ ctx.strokeStyle='#1c232f'; ctx.lineWidth=1;
    const sx = -((camera.x*camera.scale)%step), sy = -((camera.y*camera.scale)%step);
    ctx.beginPath(); for(let x=sx;x<w;x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,h); }
    for(let y=sy;y<h;y+=step){ ctx.moveTo(0,y); ctx.lineTo(w,y); } ctx.stroke();
  }

  // —à—Ç—Ä–∏—Ö–∏
  for(const s of strokes){
    ctx.save();
    ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.globalCompositeOperation = (s.mode==='erase')?'destination-out':'source-over';
    ctx.strokeStyle=s.color; ctx.lineWidth=s.size*camera.scale;
    ctx.beginPath();
    s.points.forEach((p,i)=>{const x=(p.x-camera.x)*camera.scale, y=(p.y-camera.y)*camera.scale; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);});
    ctx.stroke(); ctx.restore();
  }

  // –∫—É—Ä—Å–æ—Ä—ã (–º–∏–≥–∞—é—Ç 3 —Å–µ–∫)
  const now=Date.now();
  for(const [id,c] of cursors){
    if(now-c.ts>3000) continue;
    const x=(c.x-camera.x)*camera.scale, y=(c.y-camera.y)*camera.scale;
    ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle='#32c5ff'; ctx.fill();
  }
}

let isDown=false, lastMove=null, current=null;
const buffer = []; // –∫–æ–ø–∏–º —Ç–æ—á–∫–∏ –¥–ª—è —Å–µ—Ç–µ–≤–æ–≥–æ –±–∞—Ç—á–∏–Ω–≥–∞
let flushTimer=null;

cvs.addEventListener('pointerdown', (e)=>{ cvs.setPointerCapture(e.pointerId); isDown=true;
  const w=toWorld(e);
  current = { id:`${Date.now()}-${Math.random().toString(36).slice(2,6)}`, mode, color:(mode==='erase'?'#000000':brush.color), size:brush.size, points:[w] };
  strokes.push(current);
  enqueue({ type:'stroke_pts', id: current.id, mode: current.mode, color: current.color, size: current.size, points:[w] });
});
cvs.addEventListener('pointermove', (e)=>{
  const w=toWorld(e);
  if(mode==='move'){ if(isDown && lastMove){ camera.x -= (e.clientX-lastMove.x)/camera.scale; camera.y -= (e.clientY-lastMove.y)/camera.scale; requestRender(); } lastMove={x:e.clientX,y:e.clientY}; }
  else{
    if(isDown && current){ current.points.push(w); enqueue({ type:'stroke_pts', id: current.id, mode: current.mode, color: current.color, size: current.size, points:[w] }); requestRender(); }
  }
  Net.sendCursor({ x:w.x, y:w.y, drawing:isDown });
});
cvs.addEventListener('pointerup', ()=>{ isDown=false; lastMove=null; current=null; });

function enqueue(op){
  buffer.push(op);
  if(!flushTimer){
    flushTimer = setTimeout(()=>{ // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–∞—á–∫–æ–π —Ä–∞–∑ –≤ ~16‚Äì25 –º—Å
      Net.sendReliable({ type:'batch', ops: buffer.splice(0, buffer.length) });
      flushTimer=null;
    }, 20);
  }
}

function applyOp(op){
  if(op.type==='batch'){ for(const a of op.ops) applyOp(a); return; }
  if(op.type==='stroke_pts'){
    let s = strokes.find(x=>x.id===op.id);
    if(!s){ s={ id:op.id, mode:op.mode, color:op.color, size:op.size, points:[] }; strokes.push(s); }
    // –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–≤—ã–µ —Ç–æ—á–∫–∏
    for(const p of op.points) s.points.push(p);
    requestRender();
  }
}
</script>
