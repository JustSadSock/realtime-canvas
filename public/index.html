<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Realtime Canvas</title>
<style>
  :root{
    --bg:#fff9fb; --fg:#222; --border:#e0cfe4; --panel:#ffffffcc; --muted:#888; --accent:#ff99cc;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:800px;margin:20px auto;padding:16px;border:1px solid var(--border);border-radius:12px;background:#fff;box-shadow:0 4px 10px rgba(0,0,0,.08)}
  input,button,select{background:#fff;color:var(--fg);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font-size:16px}
  input[type=range]{padding:0}
  button{cursor:pointer;transition:background .2s,box-shadow .2s;box-shadow:0 2px 4px rgba(0,0,0,.2);background:linear-gradient(#fff,#e6e6e6)}
  button:active{transform:translateY(1px);box-shadow:inset 0 2px 4px rgba(0,0,0,.2)}
  button:hover{background:var(--accent);color:#fff}
  button.active,.swatch.active,#color.active,.sz.active{box-shadow:0 0 0 3px var(--accent);}
  .sz.active{background:var(--accent);color:#fff}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:.5rem 0}
  #rooms{display:grid;gap:8px;margin-top:8px}
  #stage{position:fixed;inset:0;display:none}
  #grid{position:absolute;inset:0;pointer-events:none}
  #cvs{position:absolute;inset:0;touch-action:none}
  #toolbar{position:fixed;left:8px;top:8px;display:none;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:8px;backdrop-filter:blur(6px);align-items:center;box-shadow:0 4px 10px rgba(0,0,0,.1)}
  #toolbar .group{display:flex;gap:6px;align-items:center}
  #toolbar .dropdown{position:relative}
  #toolbar .dropdown-menu{display:none;position:absolute;top:100%;left:0;flex-direction:column;background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:6px;gap:6px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
  #toolbar .dropdown.open .dropdown-menu{display:flex}
  #toolbar .swatch{width:26px;height:26px;border-radius:6px;border:1px solid var(--border);box-shadow:0 2px 4px rgba(0,0,0,.1)}
  #toolbar small{color:var(--muted)}
  #toolbar.mobile{left:50%;top:auto;bottom:8px;transform:translateX(-50%);flex-wrap:wrap}
  #toolbar.mobile .group{flex-wrap:wrap;justify-content:center}
  #toolbar.mobile button,#toolbar.mobile .swatch,#toolbar.mobile input[type=color]{width:40px;height:40px;font-size:20px;padding:0}
  #toolbar.mobile~.hint{display:none}
  .hint{position:fixed;right:8px;bottom:8px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 8px;font-size:12px;box-shadow:0 2px 6px rgba(0,0,0,.1)}
</style>

<div id="lobby" class="wrap">
  <h2>–ö–æ–º–Ω–∞—Ç—ã</h2>
  <div class="row">
    <input id="room" placeholder="id –∫–æ–º–Ω–∞—Ç—ã" style="flex:1" />
    <button id="create">–°–æ–∑–¥–∞—Ç—å</button>
    <button id="join">–í–æ–π—Ç–∏</button>
  </div>
  <div class="row"><button id="refresh">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button></div>
  <div id="rooms"></div>
</div>

<div id="stage">
  <canvas id="grid"></canvas>
  <canvas id="cvs"></canvas>
</div>

<div id="toolbar">
  <div class="group">
    <button id="tool-draw" class="tool" title="–ö–∏—Å—Ç—å">‚úèÔ∏è</button>
    <button id="tool-erase" class="tool" title="–õ–∞—Å—Ç–∏–∫">ü©π</button>
    <button id="tool-pan" class="tool" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ">üñêÔ∏è</button>
    <div id="more-group" class="dropdown">
      <button id="tool-more" title="–î—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã">‚ãØ</button>
      <div id="more-menu" class="dropdown-menu">
        <button id="tool-select" class="tool" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">üî≤</button>
        <button id="tool-fill" class="tool" title="–ó–∞–ª–∏–≤–∫–∞">ü™£</button>
        <button id="tool-pipette" class="tool" title="–ü–∏–ø–µ—Ç–∫–∞">üß™</button>
        <button id="tool-image" title="–í—Å—Ç–∞–≤–∏—Ç—å PNG">üñºÔ∏è</button>
      </div>
    </div>
  </div>
  <div class="group">
    <small>–¢–æ–ª—â–∏–Ω–∞</small>
    <button class="sz" data-v="2">2</button>
    <button class="sz" data-v="6">6</button>
    <button class="sz" data-v="12">12</button>
    <button class="sz" data-v="24">24</button>
    <input id="size" type="range" min="1" max="40" value="6" title="—Ç–æ–ª—â–∏–Ω–∞" />
  </div>
  <div class="group">
    <small>–¶–≤–µ—Ç</small>
    <button class="col swatch" data-c="#000000" style="background:#000"></button>
    <button class="col swatch" data-c="#ff3b30" style="background:#ff3b30"></button>
    <button class="col swatch" data-c="#34c759" style="background:#34c759"></button>
    <button class="col swatch" data-c="#007aff" style="background:#007aff"></button>
    <input id="color" class="col" type="color" value="#000000" title="—Ü–≤–µ—Ç –∫–∏—Å—Ç–∏"/>
  </div>
  <div class="group">
    <small>–ö—É—Ä—Å–æ—Ä</small>
    <input id="cursorColor" type="color" value="#007aff" title="—Ü–≤–µ—Ç –∫—É—Ä—Å–æ—Ä–∞"/>
  </div>
  <div class="group">
    <small>–§–æ–Ω</small>
    <input id="bg" type="color" value="#ffffff" title="—Ü–≤–µ—Ç —Ñ–æ–Ω–∞"/>
    <small>–°–µ—Ç–∫–∞</small>
    <input id="gridColor" type="color" value="#f0f0f0" title="—Ü–≤–µ—Ç —Å–µ—Ç–∫–∏"/>
  </div>
  <div class="group">
    <button id="undo" title="–û—Ç–º–µ–Ω–∏—Ç—å">‚Ü∂</button>
    <button id="redo" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å">‚Ü∑</button>
    <button id="export" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG">üñºÔ∏è PNG</button>
  </div>
</div>

<input id="imageLoader" type="file" accept="image/png" style="display:none" />

<div class="hint">1-5: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ‚Ä¢ 6-9: —Ä–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏ ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ: –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ</div>

<script src="net-webrtc.js"></script>
<script>
// ===== util =====
const $ = s=>document.querySelector(s);
const $$ = s=>Array.from(document.querySelectorAll(s));
const genId = ()=> `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;

// ===== canvases & camera =====
const stage = $('#stage');
const grid = $('#grid'), gtx = grid.getContext('2d');
const cvs = $('#cvs'), ctx = cvs.getContext('2d');
let DPR = Math.max(1, devicePixelRatio||1);
let camera = { x:0, y:0, scale:1 };

function resize(){
  const w = innerWidth, h = innerHeight; DPR = Math.max(1, devicePixelRatio||1);
  [grid,cvs].forEach(cn=>{ cn.width=w*DPR; cn.height=h*DPR; cn.style.width=w+'px'; cn.style.height=h+'px'; });
  ctx.setTransform(DPR,0,0,DPR,0,0); gtx.setTransform(DPR,0,0,DPR,0,0);
  drawGrid(); requestRender();
}
addEventListener('resize', resize, {passive:true});

let gridColor = '#f0f0f0';
function drawGrid(){
  const w=grid.width/DPR, h=grid.height/DPR;
  gtx.clearRect(0,0,w,h);
  const step = 200*camera.scale;
  if (step>24){
    gtx.strokeStyle = gridColor;
    gtx.lineWidth = 1;
    const sx = -((camera.x*camera.scale)%step), sy = -((camera.y*camera.scale)%step);
    gtx.beginPath();
    for(let x=sx;x<w;x+=step){ gtx.moveTo(x,0); gtx.lineTo(x,h); }
    for(let y=sy;y<h;y+=step){ gtx.moveTo(0,y); gtx.lineTo(w,y); }
    gtx.stroke();
  }
}

// ===== state =====
let roomId=null, meId=null;
let mode='draw';
let brush = { color:'#000000', size:6 };
let bgColor = '#ffffff';
let cursorColor = '#007aff';
let selection=null, selOp=null, selectionPreview=null;
let pendingImage=null, imgOp=null;

const strokes = new Map(); // id-> {id,by,mode,...}
const cache = new Map();   // –ø–æ–ª–Ω—ã–π —à—Ç—Ä–∏—Ö (–¥–ª—è redo/—Ä–µ—Å–∏–Ω–∫–∞)
const myStack = [];        // ids –º–æ–∏—Ö —à—Ç—Ä–∏—Ö–æ–≤ (–¥–ª—è undo)
const redoStack = [];      // ids –¥–ª—è redo

// ===== UI wiring =====
const toolbar = $('#toolbar');
const toolButtons = $$('.tool');
const isMobile = matchMedia('(pointer:coarse)').matches;
if(isMobile) toolbar.classList.add('mobile');
function setTool(t){ mode=t; toolButtons.forEach(btn=>btn.classList.toggle('active', btn.id==='tool-'+t)); }
$('#tool-draw').onclick = ()=> setTool('draw');
$('#tool-erase').onclick = ()=> setTool('erase');
$('#tool-pan').onclick = ()=> setTool('pan');
$('#tool-select').onclick = ()=> setTool('select');
$('#tool-fill').onclick = ()=> setTool('fill');
$('#tool-pipette').onclick = ()=> setTool('pipette');

const moreGroup = $('#more-group');
$('#tool-more').onclick = e=>{ e.stopPropagation(); moreGroup.classList.toggle('open'); };
document.addEventListener('click', e=>{ if(!moreGroup.contains(e.target)) moreGroup.classList.remove('open'); });
$('#more-menu').onclick = ()=> moreGroup.classList.remove('open');

const imageLoader = $('#imageLoader');
$('#tool-image').onclick = ()=> imageLoader.click();

const sizeButtons = $$('.sz');
function setSize(v){ brush.size=v; $('#size').value=v; sizeButtons.forEach(b=>b.classList.toggle('active', +b.dataset.v===v)); }
$('#size').oninput = e=> setSize(+e.target.value);
sizeButtons.forEach(b=> b.onclick = ()=> setSize(+b.dataset.v));

const colorInputs = $$('.col');
function setColor(c, el){ brush.color=c; $('#color').value=c; colorInputs.forEach(b=>b.classList.toggle('active', b===el)); }
$('#color').oninput = e=> setColor(e.target.value, $('#color'));
colorInputs.forEach(b=> b.onclick = ()=> setColor(b.dataset.c, b));
setTool(mode);
setSize(brush.size);
setColor(brush.color, $('#color'));
cursorColor = $('#cursorColor').value;
$('#cursorColor').oninput = e=> { cursorColor=e.target.value; };
$('#bg').oninput = e=> { bgColor=e.target.value; requestRender(); debounceSave(); };
$('#gridColor').oninput = e=> { gridColor=e.target.value; drawGrid(); };
$('#undo').onclick = undo; $('#redo').onclick = redo;
$('#export').onclick = exportPNG;
imageLoader.onchange = e=>{
  const file=e.target.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=ev=>{
    const img=new Image();
    img.onload=()=>{
      const pos=screenToWorld(innerWidth/2,innerHeight/2);
      pendingImage={img,x:pos.x,y:pos.y,w:img.width,h:img.height};
      requestRender();
    };
    img.src=ev.target.result;
  };
  reader.readAsDataURL(file);
  e.target.value='';
};

document.addEventListener('keydown',e=>{
  if(pendingImage){
    if(e.key==='Enter') finalizePendingImage();
    else if(e.key==='Escape'){ pendingImage=null; requestRender(); }
    return;
  }
  if(e.target.tagName==='INPUT') return;
  if(e.key==='1') setTool('draw');
  else if(e.key==='2') setTool('erase');
  else if(e.key==='3') setTool('select');
  else if(e.key==='4') setTool('pan');
  else if(e.key==='5') setTool('fill');
  else if(e.key==='6') setSize(2);
  else if(e.key==='7') setSize(6);
  else if(e.key==='8') setSize(12);
  else if(e.key==='9') setSize(24);
});

// ===== lobby / rooms =====
async function getSignalURL(){ const r = await fetch('config.json', {cache:'no-store'}); const j = await r.json(); return j.SIGNAL_URL; }
async function fetchRooms(){
  try{
    const url = await getSignalURL();
    return await new Promise(res=>{
      const ws = new WebSocket(url);
      const t = setTimeout(()=>{ try{ws.close()}catch{}; res([]); }, 2000);
      ws.onopen = ()=> ws.send(JSON.stringify({type:'list'}));
      ws.onmessage = e=>{ const m=JSON.parse(e.data); if(m.type==='rooms'){ clearTimeout(t); ws.close(); res(m.rooms||[]); } };
      ws.onerror = ()=>{ clearTimeout(t); res([]); };
    });
  }catch{ return []; }
}

async function renderRooms(){
  const list = await fetchRooms();
  const holder = $('#rooms'); holder.innerHTML='';
  list.forEach(r=>{
    const b=document.createElement('button'); b.textContent=`${r.id} (${r.users})`; b.onclick=()=> $('#room').value=r.id; holder.appendChild(b);
  });
}
$('#refresh').onclick = renderRooms; renderRooms();

$('#create').onclick = async ()=>{
  const rid = ($('#room').value.trim() || `room-${Math.random().toString(36).slice(2,6)}`);
  $('#room').value = rid;
  // —è –≤–µ—à—É —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ —è–≤–Ω—ã–π –≤—ã–∑–æ–≤ create (—Ä–µ–µ—Å—Ç—Ä –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–µ)
  const url = await getSignalURL();
  const ws = new WebSocket(url);
  ws.onopen = ()=> ws.send(JSON.stringify({type:'create', roomId: rid}));
  ws.onmessage = e=>{ const m=JSON.parse(e.data); if(m.type==='created'){ alert('–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞'); ws.close(); renderRooms(); } };
};

$('#join').onclick = ()=>{
  roomId = ($('#room').value.trim() || 'public-room');
  lobbyToStage();
  Net.connect(roomId,{
    onJoined: ({me, peers})=>{
      meId = me;
      // –∑–∞–ø—Ä–æ—Å–∏–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–π —Å–Ω–∞–ø—à–æ—Ç (–µ—Å–ª–∏ –µ—Å—Ç—å)
      Net.requestState();
      // –µ—Å–ª–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ —Å–µ–∫—É–Ω–¥—ã —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –ø—Ä–∏—à–ª–æ ‚Äî –ø–æ–¥–Ω–∏–º–µ–º –ª–æ–∫–∞–ª—å–Ω–æ–µ
      setTimeout(()=>{ if (strokes.size===0) loadLocal(); }, 1000);
    },
    onPeerOpen: (peerId)=>{
      // —É —Ç–æ–ª—å–∫–æ —á—Ç–æ –æ—Ç–∫—Ä—ã–≤—à–µ–≥–æ—Å—è –ø–∏—Ä–∞ –ø–æ–ø—Ä–æ—Å–∏–º —Å–Ω–∞–ø—à–æ—Ç
      Net.sendReliableTo(peerId, { type:'state_req' });
    },
    onState: (state)=>{ if(state) mergeState(state); },
    onMsg: handleMsg,
    onCursor: ({id,x,y,drawing,color})=>{ cursors.set(id,{x,y,drawing,color,ts:Date.now()}); requestRender(); }
  });
};

function lobbyToStage(){
  document.getElementById('lobby').style.display='none';
  stage.style.display='block';
  document.getElementById('toolbar').style.display='flex';
  resize();
}

// ===== drawing =====
let isDown=false, lastMove=null, current=null;
const cursors = new Map();
const touches = new Map();
let pinchStart=null;

function getTouchState(){
  const pts=[...touches.values()];
  const center={x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
  const dist=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
  return {center, dist};
}

cvs.addEventListener('pointerdown', (e)=>{
  if(pendingImage){
    cvs.setPointerCapture(e.pointerId);
    const w=toWorld(e);
    const r={x:pendingImage.x,y:pendingImage.y,w:pendingImage.w,h:pendingImage.h};
    const corner=hitCorner(w,r,10/camera.scale);
    if(corner){ imgOp={type:'resize',corner,start:w,rect:{...r}}; }
    else if(pointInRect(w,r)){ imgOp={type:'move',start:w,rect:{...r}}; }
    else{ finalizePendingImage(); }
    return;
  }
  cvs.setPointerCapture(e.pointerId);
  if(e.pointerType==='touch'){
    touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(touches.size===2){
      pinchStart={camera:{...camera},...getTouchState()};
      if(current){ strokes.delete(current.id); cache.delete(current.id); myStack.pop(); enqueue({type:'del',id:current.id}); requestRender(); }
      isDown=false; current=null;
      return;
    }
  }
  isDown=true;
  if(mode==='pipette'){
    const w=toWorld(e);
    const x=Math.round((w.x-camera.x)*camera.scale*DPR);
    const y=Math.round((w.y-camera.y)*camera.scale*DPR);
    const d=ctx.getImageData(x,y,1,1).data;
    const c="#"+((1<<24)+(d[0]<<16)+(d[1]<<8)+d[2]).toString(16).slice(1);
    setColor(c,$('#color'));
    setTool('draw');
    isDown=false;
    return;
  }
  if (e.button===1 || mode==='pan'){ lastMove={x:e.clientX,y:e.clientY}; return; }
  const w=toWorld(e);
  if (mode==='fill'){
    const id=genId();
    const s={id,by:meId,mode:'fill',color:brush.color,size:0,points:[w]};
    strokes.set(id,s); cache.set(id,s); myStack.push(id); redoStack.length=0;
    enqueue({type:'fill',id,by:meId,color:brush.color,x:w.x,y:w.y});
    requestRender(); debounceSave(); return;
  }
  if (mode==='select'){
    if(selection){ const r=selection.rect; const hit=pointInRect(w,r); const corner=hitCorner(w,r,10/camera.scale); if(corner){ selOp={type:'resize',corner,start:w,rect:{...r}}; } else if(hit){ selOp={type:'move',start:w,rect:{...r}}; } else { selection=null; selOp={type:'select',start:w}; } }
    else { selOp={type:'select',start:w}; }
    selectionPreview=null; return;
  }
  current = { id: genId(), by: meId, mode, color:(mode==='erase'?'#000000':brush.color), size:brush.size, points:[w] };
  strokes.set(current.id, current); cache.set(current.id, current); myStack.push(current.id); redoStack.length=0;
  enqueue({ type:'stroke_pts', id: current.id, by: meId, mode: current.mode, color: current.color, size: current.size, points:[w] });
  requestRender();
});

cvs.addEventListener('pointermove', (e)=>{
  if(pendingImage){
    const w=toWorld(e);
    if(imgOp){
      if(imgOp.type==='move'){
        pendingImage.x=imgOp.rect.x+(w.x-imgOp.start.x);
        pendingImage.y=imgOp.rect.y+(w.y-imgOp.start.y);
      }
      if(imgOp.type==='resize'){
        const r=imgOp.rect; let x1=r.x, y1=r.y, x2=r.x+r.w, y2=r.y+r.h;
        if(imgOp.corner.includes('l')) x1=w.x;
        if(imgOp.corner.includes('r')) x2=w.x;
        if(imgOp.corner.includes('t')) y1=w.y;
        if(imgOp.corner.includes('b')) y2=w.y;
        pendingImage.x=Math.min(x1,x2); pendingImage.y=Math.min(y1,y2);
        pendingImage.w=Math.abs(x2-x1); pendingImage.h=Math.abs(y2-y1);
      }
      requestRender();
    }
    Net.sendCursor({x:w.x,y:w.y,drawing:false,color:cursorColor});
    return;
  }
  if(e.pointerType==='touch' && touches.has(e.pointerId)){
    touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if(touches.size===2 && pinchStart){
      const {center,dist}=getTouchState();
      const before=screenToWorld(pinchStart.center.x,pinchStart.center.y,pinchStart.camera);
      camera.scale=clamp(pinchStart.camera.scale*(dist/pinchStart.dist),0.1,8);
      const after=screenToWorld(center.x,center.y);
      camera.x+=before.x-after.x; camera.y+=before.y-after.y;
      drawGrid(); requestRender();
      return;
    }
    if(touches.size>1) return;
  }
  const w=toWorld(e);
  if (e.buttons===4 || (isDown && (e.button===1 || mode==='pan'))){
    if (lastMove){ camera.x -= (e.clientX-lastMove.x)/camera.scale; camera.y -= (e.clientY-lastMove.y)/camera.scale; drawGrid(); requestRender(); }
    lastMove={x:e.clientX,y:e.clientY}; return;
  }
  if(mode==='select' && isDown && selOp){
    if(selOp.type==='select'){ selOp.rect=rectFromPoints(selOp.start,w); selectionPreview=selOp.rect; }
    if(selOp.type==='move'){
      const dx=w.x-selOp.start.x, dy=w.y-selOp.start.y;
      selection.rect={x:selOp.rect.x+dx,y:selOp.rect.y+dy,w:selOp.rect.w,h:selOp.rect.h};
      for(const id of selection.ids){
        const s=strokes.get(id);
        if(s.mode==='fill'){ s.points[0].x+=dx; s.points[0].y+=dy; }
        else if(s.mode==='image'){ s.x+=dx; s.y+=dy; }
        else{ for(const p of s.points){ p.x+=dx; p.y+=dy; } }
      }
    }
    if(selOp.type==='resize'){
      const r=selOp.rect; let x1=r.x, y1=r.y, x2=r.x+r.w, y2=r.y+r.h;
      if(selOp.corner.includes('l')) x1=w.x;
      if(selOp.corner.includes('r')) x2=w.x;
      if(selOp.corner.includes('t')) y1=w.y;
      if(selOp.corner.includes('b')) y2=w.y;
      selection.rect={x:Math.min(x1,x2),y:Math.min(y1,y2),w:Math.abs(x2-x1),h:Math.abs(y2-y1)};
      const sx=selection.rect.w/r.w, sy=selection.rect.h/r.h; const ox=r.x, oy=r.y;
      for(const id of selection.ids){
        const s=strokes.get(id);
        if(s.mode==='fill'){
          const p=s.points[0]; p.x=selection.rect.x+(p.x-ox)*sx; p.y=selection.rect.y+(p.y-oy)*sy;
        } else if(s.mode==='image'){
          const x=s.x, y=s.y;
          s.x=selection.rect.x+(x-ox)*sx; s.y=selection.rect.y+(y-oy)*sy;
          s.w*=sx; s.h*=sy;
        } else {
          for(const p of s.points){ p.x=selection.rect.x+(p.x-ox)*sx; p.y=selection.rect.y+(p.y-oy)*sy; }
        }
      }
    }
    requestRender(); Net.sendCursor({x:w.x,y:w.y,drawing:false,color:cursorColor}); return;
  }
  if(isDown && current && (mode==='draw' || mode==='erase')){
    current.points.push(w);
    enqueue({ type:'stroke_pts', id: current.id, by: meId, mode: current.mode, color: current.color, size: current.size, points:[w] });
    requestRender();
  }
  Net.sendCursor({ x:w.x, y:w.y, drawing:isDown, color:cursorColor });
});

cvs.addEventListener('pointerup', (e)=>{
  if(pendingImage){
    if(e.pointerType==='touch') touches.delete(e.pointerId);
    imgOp=null;
    return;
  }
  if(e.pointerType==='touch'){
    touches.delete(e.pointerId);
    if(pinchStart){
      if(touches.size<2) pinchStart=null;
      isDown=false; current=null; lastMove=null;
      return;
    }
  }
  isDown=false; lastMove=null;
  if(mode==='select' && selOp){
    if(selOp.type==='select' && selOp.rect){
      selection={ids:[],rect:selOp.rect};
      for(const [id,s] of strokes){ const bb=bboxOfStroke(s); if(rectsIntersect(bb,selection.rect)) selection.ids.push(id); }
      if(selection.ids.length===0) selection=null;
    } else if(selOp.type==='move' || selOp.type==='resize'){
      if(selection) for(const id of selection.ids){ const s=strokes.get(id); Net.sendReliable({type:'del',id}); const payload={...s}; Net.sendReliable({type:'add',stroke:payload}); }
    }
    selOp=null; selectionPreview=null; requestRender(); debounceSave(); current=null; return;
  }
  current=null;
});

cvs.addEventListener('pointercancel', e=>{ touches.delete(e.pointerId); pinchStart=null; });

// –∑—É–º/–ø–∞–Ω –∫–æ–ª–µ—Å–æ–º
cvs.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const mouse = { clientX:e.clientX, clientY:e.clientY };
  if (e.shiftKey){ camera.x -= e.deltaX / camera.scale; camera.y -= e.deltaY / camera.scale; drawGrid(); requestRender(); return; }
  const before = toWorld(mouse);
  const k = Math.pow(1.0015, -e.deltaY);
  camera.scale = clamp(camera.scale * k, 0.1, 8);
  const after = toWorld(mouse);
  camera.x += before.x - after.x; camera.y += before.y - after.y;
  drawGrid(); requestRender();
},{passive:false});

addEventListener('keydown', e=>{
  if(e.key==='Delete' && selection){
    for(const id of selection.ids){ strokes.delete(id); Net.sendReliable({type:'del',id}); }
    selection=null; requestRender(); debounceSave();
  }
});

function toWorld(e){ return { x: e.clientX/camera.scale + camera.x, y: e.clientY/camera.scale + camera.y }; }
function screenToWorld(x,y,cam=camera){ return { x: x/cam.scale + cam.x, y: y/cam.scale + cam.y }; }
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function rectFromPoints(a,b){ return {x:Math.min(a.x,b.x), y:Math.min(a.y,b.y), w:Math.abs(a.x-b.x), h:Math.abs(a.y-b.y)}; }
function pointInRect(p,r){ return p.x>=r.x && p.y>=r.y && p.x<=r.x+r.w && p.y<=r.y+r.h; }
function rectsIntersect(a,b){ return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y); }
function hitCorner(p,r,t){
  const x1=r.x, y1=r.y, x2=r.x+r.w, y2=r.y+r.h;
  if(Math.abs(p.x-x1)<=t && Math.abs(p.y-y1)<=t) return 'tl';
  if(Math.abs(p.x-x2)<=t && Math.abs(p.y-y1)<=t) return 'tr';
  if(Math.abs(p.x-x1)<=t && Math.abs(p.y-y2)<=t) return 'bl';
  if(Math.abs(p.x-x2)<=t && Math.abs(p.y-y2)<=t) return 'br';
  return null;
}
function bboxOfStroke(s){
  if(s.mode==='fill'){ const p=s.points[0]; return {x:p.x-1,y:p.y-1,w:2,h:2}; }
  if(s.mode==='image'){ return {x:s.x,y:s.y,w:s.w,h:s.h}; }
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; for(const p of s.points){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return {x:minX,y:minY,w:maxX-minX,h:maxY-minY};
}
function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return [(n>>16)&255,(n>>8)&255,n&255]; }
function applyFillStroke(s){
  const w=cvs.width, h=cvs.height;
  const x=Math.round((s.points[0].x-camera.x)*camera.scale*DPR);
  const y=Math.round((s.points[0].y-camera.y)*camera.scale*DPR);
  if(x<0||y<0||x>=w||y>=h) return;
  const img=ctx.getImageData(0,0,w,h);
  const data=img.data;
  const idx=(y*w+x)*4;
  const target=[data[idx],data[idx+1],data[idx+2],data[idx+3]];
  const fill=hexToRgb(s.color);
  if(target[0]===fill[0] && target[1]===fill[1] && target[2]===fill[2] && target[3]===255) return;
  const stack=[[x,y]];
  const match=i=>data[i]===target[0]&&data[i+1]===target[1]&&data[i+2]===target[2]&&data[i+3]===target[3];
  while(stack.length){
    const [cx,cy]=stack.pop();
    const i=(cy*w+cx)*4;
    if(!match(i)) continue;
    data[i]=fill[0]; data[i+1]=fill[1]; data[i+2]=fill[2]; data[i+3]=255;
    if(cx>0) stack.push([cx-1,cy]);
    if(cx<w-1) stack.push([cx+1,cy]);
    if(cy>0) stack.push([cx,cy-1]);
    if(cy<h-1) stack.push([cx,cy+1]);
  }
  ctx.putImageData(img,0,0);
}

function loadImageForStroke(s){
  const img=new Image();
  img.onload=requestRender;
  img.src=s.data;
  Object.defineProperty(s,'_img',{value:img,enumerable:false});
}

function finalizePendingImage(){
  if(!pendingImage) return;
  const arr=rasterizeImage(pendingImage);
  redoStack.length=0;
  for(const s of arr){
    strokes.set(s.id,s); cache.set(s.id,s); myStack.push(s.id);
    const payload={...s};
    Net.sendReliable({type:'add',stroke:payload});
  }
  pendingImage=null;
  requestRender(); debounceSave();
}

function rasterizeImage(pi){
  const off=document.createElement('canvas');
  off.width=pi.w; off.height=pi.h;
  const octx=off.getContext('2d');
  octx.drawImage(pi.img,0,0,pi.w,pi.h);
  const data=octx.getImageData(0,0,pi.w,pi.h).data;
  const res=[];
  for(let y=0;y<pi.h;y++){
    let x=0;
    while(x<pi.w){
      const idx=(y*pi.w+x)*4;
      const a=data[idx+3];
      if(a===0){ x++; continue; }
      const r=data[idx],g=data[idx+1],b=data[idx+2];
      const color='#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
      let x2=x+1;
      while(x2<pi.w){
        const j=(y*pi.w+x2)*4;
        if(data[j]!==r||data[j+1]!==g||data[j+2]!==b||data[j+3]!==a) break;
        x2++;
      }
      const id=genId();
      res.push({id,by:meId,mode:'draw',color,size:1,points:[{x:pi.x+x,y:pi.y+y},{x:pi.x+x2,y:pi.y+y}]});
      x=x2;
    }
  }
  return res;
}

// –±–∞—Ç—á–∏–Ω–≥ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
const buffer=[]; let flushTimer=null;
function enqueue(op){
  buffer.push(op);
  if(!flushTimer){ flushTimer=setTimeout(()=>{ Net.sendReliable({ type:'batch', ops: buffer.splice(0, buffer.length) }); flushTimer=null; }, 20); }
}

// –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä
let rerender=false; function requestRender(){ rerender=true; }
function loop(){ if(rerender){ draw(); rerender=false; } requestAnimationFrame(loop); } loop();
function draw(){
  const w=cvs.width/DPR, h=cvs.height/DPR;
  ctx.clearRect(0,0,w,h); ctx.fillStyle=bgColor; ctx.fillRect(0,0,w,h);
  for(const s of strokes.values()){
    if(s.mode==='fill'){ applyFillStroke(s); continue; }
    if(s.mode==='image'){ if(s._img) ctx.drawImage(s._img,(s.x-camera.x)*camera.scale,(s.y-camera.y)*camera.scale,s.w*camera.scale,s.h*camera.scale); continue; }
    ctx.save(); ctx.lineJoin='round'; ctx.lineCap='round';
    ctx.globalCompositeOperation = (s.mode==='erase')?'destination-out':'source-over';
    ctx.strokeStyle=s.color; ctx.lineWidth=s.size*camera.scale;
    ctx.beginPath(); s.points.forEach((p,i)=>{ const x=(p.x-camera.x)*camera.scale, y=(p.y-camera.y)*camera.scale; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke(); ctx.restore();
  }
  if(pendingImage){
    ctx.drawImage(pendingImage.img,(pendingImage.x-camera.x)*camera.scale,(pendingImage.y-camera.y)*camera.scale,pendingImage.w*camera.scale,pendingImage.h*camera.scale);
    drawSelRect({x:pendingImage.x,y:pendingImage.y,w:pendingImage.w,h:pendingImage.h});
  }
  if(selection) drawSelRect(selection.rect);
  if(selectionPreview) drawSelRect(selectionPreview);
  // –∫—É—Ä—Å–æ—Ä—ã
  const now=Date.now();
  for(const [id,c] of cursors){
    if(now-c.ts>3000) continue;
    const x=(c.x-camera.x)*camera.scale, y=(c.y-camera.y)*camera.scale;
    drawMagicWand(x,y,c.color||'#007aff');
  }
}

function drawSelRect(r){
  const x=(r.x-camera.x)*camera.scale;
  const y=(r.y-camera.y)*camera.scale;
  const w=r.w*camera.scale;
  const h=r.h*camera.scale;
  ctx.save();
  ctx.strokeStyle='#007aff';
  ctx.setLineDash([8,4]);
  ctx.strokeRect(x,y,w,h);
  ctx.setLineDash([]);
  const hs=6;
  const corners=[[x,y],[x+w,y],[x,y+h],[x+w,y+h]];
  ctx.fillStyle='#fff'; ctx.strokeStyle='#007aff';
  for(const [cx,cy] of corners){ ctx.beginPath(); ctx.rect(cx-hs/2,cy-hs/2,hs,hs); ctx.fill(); ctx.stroke(); }
  ctx.restore();
}

function drawMagicWand(x,y,color){
  const star=4;
  ctx.save();
  ctx.strokeStyle=color;
  ctx.fillStyle=color;
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(x-8,y+8);
  ctx.lineTo(x+4,y-4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x+4,y-8);
  ctx.lineTo(x+4+star,y-4);
  ctx.lineTo(x+8,y-4);
  ctx.lineTo(x+4+star,y);
  ctx.lineTo(x+4,y+4);
  ctx.lineTo(x+4-star,y);
  ctx.lineTo(x,y-4);
  ctx.lineTo(x+4-star,y-4);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

// —Å–µ—Ç–µ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
function handleMsg(op){
  if(op.type==='batch'){ for(const a of op.ops) handleMsg(a); return; }
  if(op.type==='stroke_pts'){
    let s = strokes.get(op.id);
    if(!s){ s = { id:op.id, by:op.by, mode:op.mode, color:op.color, size:op.size, points:[] }; strokes.set(op.id, s); cache.set(op.id, s); }
    for(const p of op.points) s.points.push(p);
    requestRender(); debounceSave(); return;
  }
  if(op.type==='fill'){
    const s={id:op.id,by:op.by,mode:'fill',color:op.color,size:0,points:[{x:op.x,y:op.y}]};
    strokes.set(op.id,s); cache.set(op.id,s); requestRender(); debounceSave(); return;
  }
  if(op.type==='del'){ strokes.delete(op.id); requestRender(); debounceSave(); return; }
  if(op.type==='add'){ const s = op.stroke; if(s.mode==='image') loadImageForStroke(s); strokes.set(s.id, s); cache.set(s.id, s); requestRender(); debounceSave(); return; }
  if(op.type==='state_req'){ Net.sendReliableTo(op.id, { type:'state_full', state: serializeState() }); return; }
  if(op.type==='state_full'){
    if(op.state) mergeState(op.state); return;
  }
}

function serializeState(){ return { bg: bgColor, strokes: Array.from(strokes.values()) }; }
function mergeState(state){
  try{
    if (state.bg) bgColor = state.bg;
    if (Array.isArray(state.strokes)){
      for(const s of state.strokes){ if(!strokes.has(s.id)){ if(s.mode==='image') loadImageForStroke(s); strokes.set(s.id, s); cache.set(s.id, s); } }
    }
    requestRender(); debounceSave();
  }catch{}
}

// undo/redo
function undo(){ const id = myStack.pop(); if(!id) return; Net.sendReliable({type:'del', id}); strokes.delete(id); redoStack.push(id); requestRender(); debounceSave(); }
function redo(){ const id = redoStack.pop(); if(!id) return; const s = cache.get(id); if(!s) return; strokes.set(id, s); const payload={...s}; Net.sendReliable({type:'add', stroke:payload}); myStack.push(id); requestRender(); debounceSave(); }

// PNG —ç–∫—Å–ø–æ—Ä—Ç
function exportPNG(){
  if (strokes.size===0){ alert('–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å'); return; }
  const bb = bboxOfStrokes(); if(!bb){ alert('–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å'); return; }
  const MAX=8192; const width=Math.ceil(bb.maxX-bb.minX), height=Math.ceil(bb.maxY-bb.minY);
  const scale=Math.min(MAX/width, MAX/height, 1);
  const off=document.createElement('canvas'); off.width=Math.max(1,Math.floor(width*scale)); off.height=Math.max(1,Math.floor(height*scale));
  const ox=off.getContext('2d'); ox.fillStyle=bgColor; ox.fillRect(0,0,off.width,off.height);
  for(const s of strokes.values()){
    if(s.mode==='image'){
      if(s._img) ox.drawImage(s._img,(s.x-bb.minX)*scale,(s.y-bb.minY)*scale,s.w*scale,s.h*scale);
      continue;
    }
    ox.save(); ox.globalCompositeOperation=(s.mode==='erase')?'destination-out':'source-over';
    ox.strokeStyle=s.color; ox.lineJoin='round'; ox.lineCap='round'; ox.lineWidth=s.size*scale;
    ox.beginPath(); s.points.forEach((p,i)=>{ const x=(p.x-bb.minX)*scale, y=(p.y-bb.minY)*scale; if(i===0) ox.moveTo(x,y); else ox.lineTo(x,y); }); ox.stroke(); ox.restore();
  }
  off.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='canvas.png'; a.click(); }, 'image/png');
}
function bboxOfStrokes(){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity, any=false; for(const s of strokes.values()){ const b=bboxOfStroke(s); if(b){ any=true; if(b.x<minX)minX=b.x; if(b.y<minY)minY=b.y; if(b.x+b.w>maxX)maxX=b.x+b.w; if(b.y+b.h>maxY)maxY=b.y+b.h; } } return any?{minX,minY,maxX,maxY}:null; }

// –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ü–∏—è + —Å–µ—Ä–≤–µ—Ä–Ω–∞—è
function saveLocal(){ try{ localStorage.setItem('room:'+roomId, JSON.stringify(serializeState())); }catch{} }
function loadLocal(){ try{ const j=localStorage.getItem('room:'+roomId); if(j){ const s=JSON.parse(j); if(s) mergeState(s); } }catch{} }
let saveTimer=null; function debounceSave(){ if(saveTimer) return; saveTimer=setTimeout(()=>{ saveTimer=null; saveLocal(); Net.saveState(serializeState()); }, 300); }
</script>
