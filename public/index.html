<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Realtime Canvas</title>
<style>
  :root {
    --bg: #fff9fb;
    --stage-bottom-inset: 0px; /* –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è –∫–∞–Ω–≤–∞—Å–∞ */
    --fg: #222;
    --border: #e0cfe4;
    --panel: #ffffffcc;
    --muted: #888;
    --accent: #ff99cc;
  }
  html,
  body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--fg);
    font-family:
      system-ui,
      -apple-system,
      Segoe UI,
      Roboto,
      Arial;
  }
  .wrap {
    max-width: 800px;
    margin: 20px auto;
    padding: 16px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: #fff;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
  }
  input,
  button,
  select {
    background: #fff;
    color: var(--fg);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 16px;
    touch-action: manipulation;
  }
  input[type="range"] {
    padding: 0;
  }
  button {
    cursor: pointer;
    transition:
      background 0.2s,
      box-shadow 0.2s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    background: linear-gradient(#fff, #e6e6e6);
  }
  button:active {
    transform: translateY(1px);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  button:hover {
    background: var(--accent);
    color: #fff;
  }
  button.active,
  .swatch.active,
  #color.active,
  .sz.active {
    box-shadow: 0 0 0 3px var(--accent);
  }
  .sz.active {
    background: var(--accent);
    color: #fff;
  }
  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin: 0.5rem 0;
  }
  #rooms {
    display: grid;
    gap: 8px;
    margin-top: 8px;
  }
  #rooms .room {
    padding: 8px;
    border: 1px solid var(--border);
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.2s;
  }
  #rooms .room:hover {
    background: var(--panel);
  }
  #rooms .room .hide {
    margin-left: 8px;
    cursor: pointer;
    background: none;
    border: none;
  }
  #stage {
    position: fixed;
    inset: 0;
    display: none;
  }
  #grid {
    position: absolute;
    inset: 0;
    bottom: var(--stage-bottom-inset, 0px); /* –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Å–µ—Ç–∫–∏ */
    pointer-events: none;
  }
  #cvs {
    position: absolute;
    inset: 0;
    bottom: var(--stage-bottom-inset, 0px); /* –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Ö–æ–ª—Å—Ç–∞ */
    touch-action: none;
  }
  /* –°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –ª–æ–±–±–∏ */
  #toolbar {
    display: none;
  }
  #toolbar .group {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  #toolbar .dropdown {
    position: relative;
  }
  #toolbar .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    flex-direction: column;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px;
    gap: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }
  #toolbar .dropdown.open .dropdown-menu {
    display: flex;
  }
  #toolbar .swatch {
    width: 26px;
    height: 26px;
    border-radius: 6px;
    border: 1px solid var(--border);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  #toolbar .wand {
    display: inline-block;
    transform: rotate(-20deg) scale(1.5);
  }
  #toolbar small {
    color: var(--muted);
  }
  #latency-badge {
    position: fixed;
    top: env(safe-area-inset-top, 8px);
    right: 8px;
    padding: 6px 10px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.55);
    color: #fff;
    font:
      13px/1.2 system-ui,
      sans-serif;
    z-index: 1100; /* –≤—ã—à–µ —Ç—É–ª–±–∞—Ä–∞ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ */
    backdrop-filter: blur(6px);
  }

  /* Desktop: top full-width, –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ */
  @media (min-width: 769px) and (pointer: fine) {
    #toolbar {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      padding: 8px 10px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      z-index: 1001;
    }
  }

  /* Mobile: bottom full-width, –ø–µ—Ä–µ–Ω–æ—Å –≤ 2 —Å—Ç—Ä–æ–∫–∏ –ø—Ä–∏ –Ω–µ—Ö–≤–∞—Ç–∫–µ –º–µ—Å—Ç–∞ */
  @media (max-width: 768px), (pointer: coarse) {
    #toolbar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0) + 8px);
      display: flex;
      flex-wrap: wrap;
      gap: 8px 8px;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
      z-index: 1001;
    }
    #toolbar .dropdown-menu {
      top: auto;
      bottom: 100%; /* –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≤–≤–µ—Ä—Ö */
      left: 0;
    }
    /* –ì—Ä—É–ø–ø—ã –∏ –∫–Ω–æ–ø–∫–∏ ‚Äî –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ –∏ –Ω–µ –∫—Ä–æ—à–∞—Ç—Å—è */
    #toolbar .group {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      flex: 0 1 auto;
    }
    #toolbar button,
    #toolbar .tool {
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
    }
    .hint {
      display: none;
    }
    canvas {
      block-size: auto;
    }
  }
  /* –ñ–µ—Å—Ç—ã –∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ ‚Äî —Ç–æ–ª—å–∫–æ –Ω–∞—à–∏–º–∏ —Ä—É–∫–∞–º–∏ */
  canvas {
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  .hint {
    position: fixed;
    right: 8px;
    bottom: 8px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 6px 8px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }
</style>

<div id="lobby" class="wrap">
  <h2>–ö–æ–º–Ω–∞—Ç—ã</h2>
  <div class="row">
    <input id="room" placeholder="id –∫–æ–º–Ω–∞—Ç—ã" style="flex: 1" />
    <button id="create">–°–æ–∑–¥–∞—Ç—å</button>
    <button id="join">–í–æ–π—Ç–∏</button>
  </div>
  <div class="row"><button id="refresh">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button></div>
  <div id="rooms"></div>
</div>

<div id="stage">
  <canvas id="grid"></canvas>
  <canvas id="cvs"></canvas>
</div>

<div id="latency-badge" aria-live="polite" hidden>‚Äî ms</div>

<div id="toolbar">
  <div class="group">
    <button id="tool-draw" class="tool" title="–ö–∏—Å—Ç—å">‚úèÔ∏è</button>
    <button id="tool-erase" class="tool" title="–õ–∞—Å—Ç–∏–∫">ü©π</button>
    <div id="more-group" class="dropdown">
      <button id="tool-more" title="–î—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã">‚ãØ</button>
      <div id="more-menu" class="dropdown-menu">
        <button id="tool-select" class="tool" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">
          <span class="wand">ü™Ñ</span>
        </button>
        <button id="tool-fill" class="tool" title="–ó–∞–ª–∏–≤–∫–∞">ü™£</button>
        <button id="tool-pipette" class="tool" title="–ü–∏–ø–µ—Ç–∫–∞">üß™</button>
      </div>
    </div>
  </div>
  <div class="group">
    <small>–¢–æ–ª—â–∏–Ω–∞</small>
    <button class="sz" data-v="2">2</button>
    <button class="sz" data-v="6">6</button>
    <button class="sz" data-v="12">12</button>
    <button class="sz" data-v="24">24</button>
    <input id="size" type="range" min="1" max="40" value="6" title="—Ç–æ–ª—â–∏–Ω–∞" />
  </div>
  <div class="group">
    <small>–¶–≤–µ—Ç</small>
    <button
      class="col swatch"
      data-c="#000000"
      style="background: #000"
    ></button>
    <button
      class="col swatch"
      data-c="#ff3b30"
      style="background: #ff3b30"
    ></button>
    <button
      class="col swatch"
      data-c="#34c759"
      style="background: #34c759"
    ></button>
    <button
      class="col swatch"
      data-c="#007aff"
      style="background: #007aff"
    ></button>
    <input
      id="color"
      class="col"
      type="color"
      value="#000000"
      title="—Ü–≤–µ—Ç –∫–∏—Å—Ç–∏"
    />
  </div>
  <div class="group">
    <button id="undo" title="–û—Ç–º–µ–Ω–∏—Ç—å">‚Ü∂</button>
    <button id="redo" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å">‚Ü∑</button>
    <button id="export" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG">üñºÔ∏è PNG</button>
    <button id="import" title="–ò–º–ø–æ—Ä—Ç PNG">üì• Import</button>
    <button id="leave" title="–í—ã–π—Ç–∏ –≤ –ª–æ–±–±–∏">üè†</button>
    <button id="settingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
  </div>
</div>

<input id="imageLoader" type="file" accept="image/png" style="display: none" />

<div class="hint" id="hint">
  1-5: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ‚Ä¢ 6-9: —Ä–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏ ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ:
  –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
</div>

<div
  id="settings"
  class="wrap"
  style="
    display: none;
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000; /* –º–æ–¥–∞–ª–∫–∞ –Ω–∞–¥ —Ç—É–ª–±–∞—Ä–æ–º */
    background: #fff;
    max-width: 400px;
  "
>
  <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
  <div class="row" style="flex-direction: column; gap: 4px">
    <label>–¶–≤–µ—Ç —Ñ–æ–Ω–∞ <input id="bg" type="color" value="#ffffff" /></label>
    <label
      >–¶–≤–µ—Ç —Å–µ—Ç–∫–∏ <input id="gridColor" type="color" value="#cccccc"
    /></label>
    <label
      >–¶–≤–µ—Ç –∫—É—Ä—Å–æ—Ä–∞ <input id="cursorColorInput" type="color" value="#007aff"
    /></label>
    <label
      >–ö–∏—Å—Ç—å <input class="hk" data-action="draw" value="1" size="2"
    /></label>
    <label
      >–õ–∞—Å—Ç–∏–∫ <input class="hk" data-action="erase" value="2" size="2"
    /></label>
    <label
      >–í—ã–¥–µ–ª–µ–Ω–∏–µ <input class="hk" data-action="select" value="3" size="2"
    /></label>
    <label
      >–ó–∞–ª–∏–≤–∫–∞ <input class="hk" data-action="fill" value="5" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 2 <input class="hk" data-action="size2" value="6" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 6 <input class="hk" data-action="size6" value="7" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 12 <input class="hk" data-action="size12" value="8" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 24 <input class="hk" data-action="size24" value="9" size="2"
    /></label>
    <label class="row">
      <input type="checkbox" id="opt-latency" /> –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É —Å–µ—Ä–≤–µ—Ä–∞
    </label>
  </div>
  <div class="row"><button id="settingsClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<script type="module" src="raster-import.js"></script>
<script type="module" src="embed-png.js"></script>
<script>
  window.schedulePull ||= function () {};
</script>
<script src="net-webrtc.js"></script>
<script type="module">
  import { exportEmbeddedPNG } from "./embed-png.js";
  // ===== util =====
  const $ = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));
  const genId = () => `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

  // ===== canvases & camera =====
  const grid = $("#grid"),
    gtx = grid.getContext("2d");
  const cvs = $("#cvs"),
    ctx = cvs.getContext("2d");
  cvs.addEventListener("dblclick", (e) => e.preventDefault(), {
    passive: false,
  });
  ["gesturestart", "gesturechange", "gestureend"].forEach((evt) =>
    cvs.addEventListener(evt, (e) => e.preventDefault(), { passive: false }),
  );
  function isMobileUI() {
    return matchMedia("(max-width: 768px), (pointer: coarse)").matches;
  }
  function getStageInsetPx() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--stage-bottom-inset",
    );
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : 0;
  }
  function adjustBottomInset() {
    const tb = document.getElementById("toolbar");
    if (!tb) {
      return;
    }
    // —Å—á–∏—Ç–∞–µ–º –∏–Ω—Å–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Ç—É–ª–±–∞—Ä –≤–∏–¥–µ–Ω –∏ –º—ã –≤ –º–æ–±–∏–ª—å–Ω–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–µ
    let inset = 0;
    if (isMobileUI() && tb.style.display !== "none") {
      const h = tb.getBoundingClientRect().height; // 1 –∏–ª–∏ 2 —Å—Ç—Ä–æ–∫–∏
      inset = Math.ceil(h + 8);
    }
    // –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Ö–æ–ª—Å—Ç–∞ –∏ —Å–µ—Ç–∫–∏
    document.documentElement.style.setProperty(
      "--stage-bottom-inset",
      inset + "px",
    );
    // –ø–µ—Ä–µ—Å—á—ë—Ç —Ä–∞–∑–º–µ—Ä–æ–≤ –∫–∞–Ω–≤–∞—Å–æ–≤ –ø–æ–¥ –Ω–æ–≤—ã–π –∏–Ω—Å–µ—Ç
    resize();
  }
  if ("ResizeObserver" in window) {
    new ResizeObserver(adjustBottomInset).observe(
      document.getElementById("toolbar"),
    );
  } else {
    addEventListener("resize", () => setTimeout(adjustBottomInset, 0));
  }
  adjustBottomInset();
  addEventListener("orientationchange", () =>
    setTimeout(adjustBottomInset, 200),
  );
  {
    const mql = matchMedia("(max-width: 768px), (pointer: coarse)");
    if (mql.addEventListener) {
      mql.addEventListener("change", adjustBottomInset);
    } else if (mql.addListener) {
      mql.addListener(adjustBottomInset);
    }
  }
  let DPR = Math.max(1, devicePixelRatio || 1);
  let camera = { x: 0, y: 0, scale: 1 };

  function resize() {
    const w = innerWidth;
    // —É–º–µ–Ω—å—à–∞–µ–º –≤—ã—Å–æ—Ç—É —Å—Ü–µ–Ω—ã –Ω–∞ –º–æ–±–∏–ª—å–Ω–æ–º –Ω–∞ –≤–µ–ª–∏—á–∏–Ω—É –∏–Ω—Å–µ—Ç–∞
    const inset = isMobileUI() ? getStageInsetPx() : 0;
    const h = Math.max(0, innerHeight - inset);
    DPR = Math.max(1, devicePixelRatio || 1);
    [grid, cvs].forEach((cn) => {
      cn.width = w * DPR;
      cn.height = h * DPR;
      cn.style.width = w + "px";
      cn.style.height = h + "px";
    });
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    gtx.setTransform(DPR, 0, 0, DPR, 0, 0);
    drawGrid();
    requestRender();
  }
  addEventListener("resize", resize, { passive: true });

  function setCompositeForTool(context, tool) {
    context.globalCompositeOperation =
      tool === "erase" ? "destination-out" : "source-over";
  }

  let gridColor = "#cccccc";
  function drawGrid() {
    const w = grid.width / DPR,
      h = grid.height / DPR;
    gtx.fillStyle = bgColor;
    gtx.fillRect(0, 0, w, h);
    const step = 100 * camera.scale;
    if (step > 24) {
      gtx.strokeStyle = gridColor;
      gtx.lineWidth = 1;
      const sx = -((camera.x * camera.scale) % step),
        sy = -((camera.y * camera.scale) % step);
      gtx.beginPath();
      for (let x = sx; x < w; x += step) {
        gtx.moveTo(x, 0);
        gtx.lineTo(x, h);
      }
      for (let y = sy; y < h; y += step) {
        gtx.moveTo(0, y);
        gtx.lineTo(w, y);
      }
      gtx.stroke();
    }
  }

  // ===== state =====
  let roomId = null,
    meId = null; // –º–æ–π peer id
  let rev = 0; // —Ä–µ–≤–∏–∑–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è (–º–æ–Ω–æ—Ç–æ–Ω–Ω–æ —Ä–∞—Å—Ç—ë—Ç)
  window.rev = rev;
  function setRev(v) {
    rev = v | 0;
    window.rev = rev;
  }
  let mode = "draw";
  let brush = { color: "#000000", size: 6 };
  let bgColor = "#ffffff";
  let selection = null,
    selOp = null,
    selectionPreview = null;
  let cursorColor = "#007aff";
  window.importActive = false;
  const defaultHotkeys = {
    draw: "1",
    erase: "2",
    select: "3",
    fill: "5",
    size2: "6",
    size6: "7",
    size12: "8",
    size24: "9",
  };
  let hotkeys = { ...defaultHotkeys };
  function loadSettings() {
    try {
      const s = JSON.parse(localStorage.getItem("settings"));
      if (s) {
        if (s.hotkeys) Object.assign(hotkeys, s.hotkeys);
        if (s.cursorColor) cursorColor = s.cursorColor;
      }
    } catch {}
  }
  function saveSettings() {
    try {
      localStorage.setItem(
        "settings",
        JSON.stringify({ hotkeys, cursorColor }),
      );
    } catch {}
  }
  function sendPresence() {
    if (meId == null) return;
    cursorsMeta.set(meId, { color: cursorColor });
    Net.sendReliable({ type: "presence", cursorColor });
  }
  loadSettings();
  function renderHint() {
    $("#hint").textContent =
      `–ö–∏—Å—Ç—å: ${hotkeys.draw} ‚Ä¢ –õ–∞—Å—Ç–∏–∫: ${hotkeys.erase} ‚Ä¢ –í—ã–¥–µ–ª–µ–Ω–∏–µ: ${hotkeys.select} ‚Ä¢ –ó–∞–ª–∏–≤–∫–∞: ${hotkeys.fill} ‚Ä¢ –†–∞–∑–º–µ—Ä: ${hotkeys.size2}/${hotkeys.size6}/${hotkeys.size12}/${hotkeys.size24} ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ: –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ Shift –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ: —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ`;
  }
  renderHint();

  const strokes = new Map(); // id-> {id,by,mode,...}
  const cache = new Map(); // –ø–æ–ª–Ω—ã–π —à—Ç—Ä–∏—Ö (–¥–ª—è redo/—Ä–µ—Å–∏–Ω–∫–∞)
  const myStack = []; // ids –º–æ–∏—Ö —à—Ç—Ä–∏—Ö–æ–≤ (–¥–ª—è undo)
  const redoStack = []; // ids –¥–ª—è redo
  const rasterDirty = new Set();
  const deleted = new Set();


  const patternCanvas = document.createElement("canvas");
  patternCanvas.width = 8;
  patternCanvas.height = 8;
  const ptx = patternCanvas.getContext("2d");
  let selPattern = null;
  function updateSelPattern() {
    ptx.clearRect(0, 0, 8, 8);
    ptx.strokeStyle = cursorColor;
    ptx.lineWidth = 1;
    ptx.beginPath();
    ptx.moveTo(0, 0);
    ptx.lineTo(8, 8);
    ptx.moveTo(0, 8);
    ptx.lineTo(8, 0);
    ptx.stroke();
    selPattern = ctx.createPattern(patternCanvas, "repeat");
  }
  updateSelPattern();

  // ===== UI wiring =====
  const toolButtons = $$(".tool");
  function setTool(t) {
    mode = t;
    toolButtons.forEach((btn) =>
      btn.classList.toggle("active", btn.id === "tool-" + t),
    );
  }
  $("#tool-draw").onclick = () => setTool("draw");
  $("#tool-erase").onclick = () => setTool("erase");
  $("#tool-select").onclick = () => setTool("select");
  $("#tool-fill").onclick = () => setTool("fill");
  $("#tool-pipette").onclick = () => setTool("pipette");

  const moreGroup = $("#more-group");
  $("#tool-more").onclick = (e) => {
    e.stopPropagation();
    moreGroup.classList.toggle("open");
  };
  document.addEventListener("click", (e) => {
    if (!moreGroup.contains(e.target)) moreGroup.classList.remove("open");
  });
  $("#more-menu").onclick = () => moreGroup.classList.remove("open");

  const optLatency = document.getElementById("opt-latency");
  const latencyBadge = document.getElementById("latency-badge");
  const LATENCY_KEY = "opt-latency";
  optLatency.checked = JSON.parse(localStorage.getItem(LATENCY_KEY) || "false");
  latencyBadge.hidden = !optLatency.checked;
  optLatency.addEventListener("change", () => {
    localStorage.setItem(LATENCY_KEY, optLatency.checked);
    latencyBadge.hidden = !optLatency.checked;
  });
  let pingTimer = null;
  function startPing() {
    if (pingTimer) return;
    pingTimer = setInterval(sendPing, 5000);
  }
  function stopPing() {
    if (!pingTimer) return;
    clearInterval(pingTimer);
    pingTimer = null;
  }
  function sendPing() {
    if (!optLatency.checked) return;
    const t = performance.now();
    Net.pingServer(t);
  }

  const imageLoader = $("#imageLoader");

  const sizeButtons = $$(".sz");
  function setSize(v) {
    brush.size = v;
    $("#size").value = v;
    sizeButtons.forEach((b) =>
      b.classList.toggle("active", +b.dataset.v === v),
    );
  }
  $("#size").oninput = (e) => setSize(+e.target.value);
  sizeButtons.forEach((b) => (b.onclick = () => setSize(+b.dataset.v)));

  const colorInputs = $$(".col");
  function setColor(c, el) {
    brush.color = c;
    $("#color").value = c;
    colorInputs.forEach((b) => b.classList.toggle("active", b === el));
  }
  $("#color").oninput = (e) => setColor(e.target.value, $("#color"));
  colorInputs.forEach((b) => (b.onclick = () => setColor(b.dataset.c, b)));
  setTool(mode);
  setSize(brush.size);
  setColor(brush.color, $("#color"));
  $("#bg").oninput = (e) => {
    bgColor = e.target.value;
    drawGrid();
    requestRender();
    debounceSave();
  };
  $("#gridColor").oninput = (e) => {
    gridColor = e.target.value;
    drawGrid();
  };
  $("#undo").onclick = undo;
  $("#redo").onclick = redo;
  $("#export").onclick = exportPNG;
  $("#import").onclick = () => imageLoader.click();
  $("#leave").onclick = leaveRoom;
  $("#settingsBtn").onclick = () => {
    $("#settings").style.display = "block";
    $$(".hk").forEach((inp) => (inp.value = hotkeys[inp.dataset.action] || ""));
    $("#cursorColorInput").value = cursorColor;
  };
  $("#settingsClose").onclick = () => {
    $("#settings").style.display = "none";
    saveSettings();
    renderHint();
  };
  $$(".hk").forEach((inp) => {
    inp.oninput = () => {
      hotkeys[inp.dataset.action] = inp.value;
      saveSettings();
      renderHint();
    };
  });
  $("#cursorColorInput").oninput = (e) => {
    cursorColor = e.target.value;
    updateSelPattern();
    saveSettings();
    sendPresence();
    requestRender();
  };
  imageLoader.onchange = async (e) => {
    const file = e.target.files[0];
    if (file) await window.beginImport(file);
    e.target.value = "";
  };
  document.addEventListener("paste", async (e) => {
    const item = [...(e.clipboardData?.items || [])].find(
      (it) => it.type.startsWith("image/"),
    );
    if (item) {
      const file = item.getAsFile();
      if (file) await window.beginImport(file);
    }
  });
  cvs.addEventListener("dragover", (e) => {
    e.preventDefault();
  });
  cvs.addEventListener("drop", async (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file) await window.beginImport(file);
  });
  window.addEventListener("dragover", (e) => {
    e.preventDefault();
  });
  window.addEventListener("drop", async (e) => {
    e.preventDefault();
    const f = e.dataTransfer.files[0];
    if (f) await window.beginImport(f);
  });

  document.addEventListener("keydown", (e) => {
    if (window.importActive) return;
    if (e.target.tagName === "INPUT") return;
    const k = e.key;
    if (k === hotkeys.draw) setTool("draw");
    else if (k === hotkeys.erase) setTool("erase");
    else if (k === hotkeys.select) setTool("select");
    else if (k === hotkeys.fill) setTool("fill");
    else if (k === hotkeys.size2) setSize(2);
    else if (k === hotkeys.size6) setSize(6);
    else if (k === hotkeys.size12) setSize(12);
    else if (k === hotkeys.size24) setSize(24);
  });

  // ===== lobby / rooms =====
  async function getSignalURL() {
    const r = await fetch("config.json", { cache: "no-store" });
    const j = await r.json();
    return j.SIGNAL_URL;
  }
  async function fetchRooms() {
    try {
      const url = await getSignalURL();
      return await new Promise((res) => {
        const ws = new WebSocket(url);
        const t = setTimeout(() => {
          try {
            ws.close();
          } catch {}
          res([]);
        }, 2000);
        ws.onopen = () => ws.send(JSON.stringify({ type: "list" }));
        ws.onmessage = (e) => {
          const m = JSON.parse(e.data);
          if (m.type === "rooms") {
            clearTimeout(t);
            ws.close();
            res(m.rooms || []);
          }
        };
        ws.onerror = () => {
          clearTimeout(t);
          res([]);
        };
      });
    } catch {
      return [];
    }
  }

  function getHiddenRooms() {
    try {
      return JSON.parse(localStorage.getItem("hiddenRooms")) || [];
    } catch {
      return [];
    }
  }
  function hideRoom(id) {
    const h = getHiddenRooms();
    if (!h.includes(id)) h.push(id);
    try {
      localStorage.setItem("hiddenRooms", JSON.stringify(h));
    } catch {}
    renderRooms();
  }

  async function renderRooms() {
    const list = await fetchRooms();
    const holder = $("#rooms");
    holder.innerHTML = "";
    const hidden = getHiddenRooms();
    list.forEach((r) => {
      if (hidden.includes(r.id)) return;
      const card = document.createElement("div");
      card.className = "room";
      card.textContent = `${r.id} (${r.users})`;
      card.onclick = () => joinRoom(r.id);
      const del = document.createElement("button");
      del.className = "hide";
      del.textContent = "üóë";
      del.onclick = (e) => {
        e.stopPropagation();
        hideRoom(r.id);
      };
      card.appendChild(del);
      holder.appendChild(card);
    });
  }
  $("#refresh").onclick = renderRooms;
  renderRooms();

  $("#create").onclick = async () => {
    const rid =
      $("#room").value.trim() ||
      `room-${Math.random().toString(36).slice(2, 6)}`;
    $("#room").value = rid;
    // —è –≤–µ—à—É —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ —è–≤–Ω—ã–π –≤—ã–∑–æ–≤ create (—Ä–µ–µ—Å—Ç—Ä –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–µ)
    const url = await getSignalURL();
    const ws = new WebSocket(url);
    ws.onopen = () => ws.send(JSON.stringify({ type: "create", roomId: rid }));
    ws.onmessage = (e) => {
      const m = JSON.parse(e.data);
      if (m.type === "created") {
        alert("–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞");
        ws.close();
        renderRooms();
      }
    };
  };

  function joinRoom(id) {
    setRev(0);
    roomId = id;
    lastPull = 0;
    if (pullTimer) {
      clearTimeout(pullTimer);
      pullTimer = null;
    }
    lobbyToStage();
    Net.connect(roomId, {
      onJoined: ({ me, roomId, peers }) => {
        meId = me; // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–æ–π id
        cursorsMeta.set(me, { color: cursorColor });
        sendPresence();
        Net.requestState(); // —Å–µ—Ä–≤–µ—Ä–Ω—ã–π —Å–Ω–∞–ø—à–æ—Ç
        setTimeout(() => {
          if (strokes.size === 0) loadLocal();
        }, 1000);
        startPing();
      },
      onPeerOpen: (peerId) => {
        // –ø–æ–ø—Ä–æ—Å–∏—Ç—å —Å–Ω–∞–ø—à–æ—Ç –∞–¥—Ä–µ—Å–Ω–æ –∏ —É–∫–∞–∑–∞—Ç—å –∫—Ç–æ –ø—Ä–æ—Å–∏—Ç
        Net.sendReliableTo(peerId, { type: "state_req", id: meId });
        sendPresence();
      },
      onState: (state) => {
        if (state) mergeState(state, { fromServer: true });
      },
      onMsg: handleMsg,
      onCursor: ({ id, x, y, drawing }) => {
        cursors.set(id, { x, y, drawing, ts: Date.now() });
        requestRender();
      },
      onPong: (t) => {
        if (latencyBadge.hidden) return;
        const rtt = Math.max(0, Math.round(performance.now() - t));
        const newText = rtt + " ms";
        if (latencyBadge.textContent !== newText)
          latencyBadge.textContent = newText;
      },
      onClose: () => stopPing(),
    });
  }
  $("#join").onclick = () => joinRoom($("#room").value.trim() || "public-room");

  function lobbyToStage() {
    document.getElementById("lobby").style.display = "none";
    document.getElementById("stage").style.display = "block";
    document.getElementById("toolbar").style.display = "flex";
    resize();
    adjustBottomInset();
  }

  // ===== drawing =====
  let isDown = false,
    lastMove = null,
    current = null;
  const cursors = new Map();
  const cursorsMeta = new Map();
  const touches = new Map();
  let pinchStart = null;

  function getTouchState() {
    const pts = [...touches.values()];
    const center = {
      x: (pts[0].x + pts[1].x) / 2,
      y: (pts[0].y + pts[1].y) / 2,
    };
    const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    return { center, dist };
  }

  cvs.addEventListener("pointerdown", (e) => {
    cvs.setPointerCapture(e.pointerId);
    if (e.pointerType === "touch") {
      touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (touches.size === 2) {
        pinchStart = { camera: { ...camera }, ...getTouchState() };
        if (current) {
          strokes.delete(current.id);
          cache.delete(current.id);
          myStack.pop();
          deleted.add(current.id);
          enqueue({ type: "del", id: current.id });
          requestRender();
        }
        isDown = false;
        current = null;
        return;
      }
    }
    isDown = true;
    if (mode === "pipette") {
      const w = toWorld(e);
      const x = Math.round((w.x - camera.x) * camera.scale * DPR);
      const y = Math.round((w.y - camera.y) * camera.scale * DPR);
      const d = ctx.getImageData(x, y, 1, 1).data;
      const c =
        "#" +
        ((1 << 24) + (d[0] << 16) + (d[1] << 8) + d[2]).toString(16).slice(1);
      setColor(c, $("#color"));
      setTool("draw");
      isDown = false;
      return;
    }
    if (e.button === 1) {
      lastMove = { x: e.clientX, y: e.clientY };
      return;
    }
    const w = toWorld(e);
    if (mode === "fill") {
      performFill(w);
      return;
    }
    if (mode === "select") {
      if (selection) {
        const r = selection.rect;
        const hit = pointInRect(w, r);
        const corner = hitCorner(w, r, 10 / camera.scale);
        if (corner) {
          selOp = {
            type: "resize",
            corner,
            start: w,
            rect: { ...r },
            orig: new Map(),
            path: selection.path.map((p) => ({ ...p })),
          };
          for (const id of selection.ids)
            selOp.orig.set(id, cloneStroke(strokes.get(id)));
        } else if (hit) {
          selOp = {
            type: "move",
            start: w,
            rect: { ...r },
            orig: new Map(),
            path: selection.path.map((p) => ({ ...p })),
          };
          for (const id of selection.ids)
            selOp.orig.set(id, cloneStroke(strokes.get(id)));
        } else {
          selection = null;
          selOp = { type: "select", points: [w] };
        }
      } else {
        selOp = { type: "select", points: [w] };
      }
      selectionPreview = null;
      return;
    }
    current = {
      id: genId(),
      by: meId,
      mode,
      color: mode === "erase" ? undefined : brush.color,
      size: brush.size,
      points: [w],
    };
    strokes.set(current.id, current);
    cache.set(current.id, current);
    deleted.delete(current.id);
    myStack.push(current.id);
    redoStack.length = 0;
    enqueue({
      type: "stroke_pts",
      id: current.id,
      by: meId,
      mode: current.mode,
      tool: current.mode,
      color: current.color,
      size: current.size,
      points: [w],
    });
    requestRender();
  });

  cvs.addEventListener("pointermove", (e) => {
    if (e.pointerType === "touch" && touches.has(e.pointerId)) {
      touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (touches.size === 2 && pinchStart) {
        const { center, dist } = getTouchState();
        const before = screenToWorld(
          pinchStart.center.x,
          pinchStart.center.y,
          pinchStart.camera,
        );
        camera.scale = clamp(
          pinchStart.camera.scale * (dist / pinchStart.dist),
          0.1,
          8,
        );
        const after = screenToWorld(center.x, center.y);
        camera.x += before.x - after.x;
        camera.y += before.y - after.y;
        drawGrid();
        requestRender();
        return;
      }
      if (touches.size > 1) return;
    }
    const w = toWorld(e);
    if (e.buttons === 4 || (isDown && e.button === 1)) {
      if (lastMove) {
        camera.x -= (e.clientX - lastMove.x) / camera.scale;
        camera.y -= (e.clientY - lastMove.y) / camera.scale;
        drawGrid();
        requestRender();
      }
      lastMove = { x: e.clientX, y: e.clientY };
      return;
    }
    if (mode === "select" && isDown && selOp) {
      if (selOp.type === "select") {
        selOp.points.push(w);
        selectionPreview = selOp.points.slice();
      }
      if (selOp.type === "move") {
        const dx = w.x - selOp.start.x,
          dy = w.y - selOp.start.y;
        selection.rect = {
          x: selOp.rect.x + dx,
          y: selOp.rect.y + dy,
          w: selOp.rect.w,
          h: selOp.rect.h,
        };
        selection.path = selOp.path.map((p) => ({ x: p.x + dx, y: p.y + dy }));
        for (const id of selection.ids) {
          const o = selOp.orig.get(id);
          const s = strokes.get(id);
          if (s.mode === "image") {
            s.x = o.x + dx;
            s.y = o.y + dy;
          } else if (s.mode === "raster") {
            s.runs = o.runs.map((r) => {
              const y = Math.round(r.y + dy);
              const x0 = Math.round(r.x0 + dx);
              const x1 = Math.round(r.x1 + dx);
              return { y, x0, x1, color: r.color };
            });
            s.rowH = o.rowH ?? 1;
            updateRasterBBox(s);
          } else {
            s.points = o.points.map((p) => ({ x: p.x + dx, y: p.y + dy }));
          }
        }
      }
      if (selOp.type === "resize") {
        const r = selOp.rect;
        let x1 = r.x,
          y1 = r.y,
          x2 = r.x + r.w,
          y2 = r.y + r.h;
        if (selOp.corner.includes("l")) x1 = w.x;
        if (selOp.corner.includes("r")) x2 = w.x;
        if (selOp.corner.includes("t")) y1 = w.y;
        if (selOp.corner.includes("b")) y2 = w.y;
        const rect = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          w: Math.abs(x2 - x1),
          h: Math.abs(y2 - y1),
        };
        selection.rect = rect;
        const sx = r.w ? rect.w / r.w : 1,
          sy = r.h ? rect.h / r.h : 1;
        const ox = r.x,
          oy = r.y;
        selection.path = selOp.path.map((p) => ({
          x: rect.x + (p.x - ox) * sx,
          y: rect.y + (p.y - oy) * sy,
        }));
        for (const id of selection.ids) {
          const o = selOp.orig.get(id);
          const s = strokes.get(id);
          if (s.mode === "image") {
            s.x = rect.x + (o.x - ox) * sx;
            s.y = rect.y + (o.y - oy) * sy;
            s.w = o.w * sx;
            s.h = o.h * sy;
          } else if (s.mode === "raster") {
            s.runs = o.runs.map((r) => {
              const y = Math.round(rect.y + (r.y - oy) * sy);
              const x0 = Math.round(rect.x + (r.x0 - ox) * sx);
              const x1 = Math.round(rect.x + (r.x1 - ox) * sx);
              return { y, x0, x1, color: r.color };
            });
            s.rowH = (o.rowH ?? 1) * sy;
            updateRasterBBox(s);
          } else {
            s.points = o.points.map((p) => ({
              x: rect.x + (p.x - ox) * sx,
              y: rect.y + (p.y - oy) * sy,
            }));
          }
        }
      }
      requestRender();
      Net.sendCursor({ x: w.x, y: w.y, drawing: false });
      return;
    }
    if (isDown && current && (mode === "draw" || mode === "erase")) {
      current.points.push(w);
      enqueue({
        type: "stroke_pts",
        id: current.id,
        by: meId,
        mode: current.mode,
        tool: current.mode,
        color: current.color,
        size: current.size,
        points: [w],
      });
      requestRender();
    }
    if (mode === "erase" && isDown) {
      const rad = brush.size / 2;
      let changed = false;
      for (const [id, s] of strokes) {
        if (s === current) continue;
        if (s.mode === "raster") {
          if (!s._bbox) updateRasterBBox(s);
          if (!circleIntersectsBBox(w.x, w.y, rad, s._bbox)) continue;
          eraseRasterStroke(s, w.x, w.y, rad);
          rasterDirty.add(s.id);
          changed = true;
        }
      }
      if (changed) {
        requestRender();
      }
    }
    Net.sendCursor({ x: w.x, y: w.y, drawing: isDown });
  });

  cvs.addEventListener("pointerup", (e) => {
    if (e.pointerType === "touch") {
      touches.delete(e.pointerId);
      if (pinchStart) {
        if (touches.size < 2) pinchStart = null;
        isDown = false;
        current = null;
        lastMove = null;
        return;
      }
    }
    isDown = false;
    lastMove = null;
    if (mode === "select" && selOp) {
      if (selOp.type === "select" && selOp.points) {
        const poly = selOp.points;
        const rect = bboxOfPoints(poly);
        selection = { ids: [], path: poly, rect };
        for (const [id, s] of strokes) {
          if (strokeIntersectsPoly(s, poly)) selection.ids.push(id);
        }
        if (selection.ids.length === 0) selection = null;
      } else if (selOp.type === "move" || selOp.type === "resize") {
        if (selection)
          for (const id of selection.ids) {
            const s = strokes.get(id);
            Net.sendReliable({ type: "del", id });
            const payload = { ...s };
            if (payload._bbox) delete payload._bbox;
            Net.sendReliable({ type: "add", stroke: payload });
          }
      }
      selOp = null;
      selectionPreview = null;
      requestRender();
      debounceSave();
      current = null;
      return;
    }
    current = null;
    if (rasterDirty.size) {
      const ops = [];
      for (const id of rasterDirty) {
        const s = strokes.get(id);
        if (!s) continue;
        compactRuns(s);
        ops.push({ type: "del", id });
        if (s.runs.length) {
          const payload = { ...s };
          if (payload._bbox) delete payload._bbox;
          ops.push({ type: "add", stroke: payload });
        } else {
          strokes.delete(id);
        }
      }
      Net.sendReliable({ type: "batch", ops });
      rasterDirty.clear();
      debounceSave();
    }
  });

  cvs.addEventListener("pointercancel", (e) => {
    touches.delete(e.pointerId);
    pinchStart = null;
  });

  // –∑—É–º/–ø–∞–Ω –∫–æ–ª–µ—Å–æ–º
  cvs.addEventListener(
    "wheel",
    (e) => {
      e.preventDefault();
      const mouse = { clientX: e.clientX, clientY: e.clientY };
      if (e.shiftKey) {
        camera.x -= e.deltaX / camera.scale;
        camera.y -= e.deltaY / camera.scale;
        drawGrid();
        requestRender();
        return;
      }
      const before = toWorld(mouse);
      const k = Math.pow(1.0015, -e.deltaY);
      camera.scale = clamp(camera.scale * k, 0.1, 8);
      const after = toWorld(mouse);
      camera.x += before.x - after.x;
      camera.y += before.y - after.y;
      drawGrid();
      requestRender();
    },
    { passive: false },
  );

  addEventListener("keydown", (e) => {
    if (window.importActive) return;
    if (e.key === "Delete" && selection) {
      for (const id of selection.ids) {
        strokes.delete(id);
        deleted.add(id);
        Net.sendReliable({ type: "del", id });
      }
      selection = null;
      requestRender();
      debounceSave();
    }
  });

  function toWorld(e) {
    return {
      x: e.clientX / camera.scale + camera.x,
      y: e.clientY / camera.scale + camera.y,
    };
  }
  function screenToWorld(x, y, cam = camera) {
    return { x: x / cam.scale + cam.x, y: y / cam.scale + cam.y };
  }
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  function rectFromPoints(a, b) {
    return {
      x: Math.min(a.x, b.x),
      y: Math.min(a.y, b.y),
      w: Math.abs(a.x - b.x),
      h: Math.abs(a.y - b.y),
    };
  }
  function pointInRect(p, r) {
    return p.x >= r.x && p.y >= r.y && p.x <= r.x + r.w && p.y <= r.y + r.h;
  }
  function rectsIntersect(a, b) {
    return !(
      a.x + a.w < b.x ||
      b.x + b.w < a.x ||
      a.y + a.h < b.y ||
      b.y + b.h < a.y
    );
  }
  function hitCorner(p, r, t) {
    const x1 = r.x,
      y1 = r.y,
      x2 = r.x + r.w,
      y2 = r.y + r.h;
    if (Math.abs(p.x - x1) <= t && Math.abs(p.y - y1) <= t) return "tl";
    if (Math.abs(p.x - x2) <= t && Math.abs(p.y - y1) <= t) return "tr";
    if (Math.abs(p.x - x1) <= t && Math.abs(p.y - y2) <= t) return "bl";
    if (Math.abs(p.x - x2) <= t && Math.abs(p.y - y2) <= t) return "br";
    return null;
  }
  function bboxOfPoints(pts) {
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const p of pts) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }
  function pointInPoly(p, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i].x,
        yi = poly[i].y,
        xj = poly[j].x,
        yj = poly[j].y;
      const intersect =
        yi > p.y != yj > p.y && p.x < ((xj - xi) * (p.y - yi)) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function polyIntersectsRect(poly, rx, ry, rw, rh) {
    const pb = bboxOfPoints(poly);
    if (pb.x > rx + rw || pb.x + pb.w < rx || pb.y > ry + rh || pb.y + pb.h < ry)
      return false;
    const rectPts = [
      { x: rx, y: ry },
      { x: rx + rw, y: ry },
      { x: rx, y: ry + rh },
      { x: rx + rw, y: ry + rh },
    ];
    if (rectPts.some((p) => pointInPoly(p, poly))) return true;
    const inRect = (p) => p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh;
    if (poly.some(inRect)) return true;
    const segInt = (a, b, c, d) => {
      const s1x = b.x - a.x,
        s1y = b.y - a.y,
        s2x = d.x - c.x,
        s2y = d.y - c.y;
      const s = (-s1y * (a.x - c.x) + s1x * (a.y - c.y)) / (-s2x * s1y + s1x * s2y);
      const t = (s2x * (a.y - c.y) - s2y * (a.x - c.x)) / (-s2x * s1y + s1x * s2y);
      return s >= 0 && s <= 1 && t >= 0 && t <= 1;
    };
    const rectEdges = [
      [rectPts[0], rectPts[1]],
      [rectPts[1], rectPts[3]],
      [rectPts[3], rectPts[2]],
      [rectPts[2], rectPts[0]],
    ];
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const e1 = [poly[j], poly[i]];
      if (rectEdges.some((e2) => segInt(e1[0], e1[1], e2[0], e2[1]))) return true;
    }
    return false;
  }
  function strokeIntersectsPoly(s, poly) {
    if (s.mode === "image") {
      const pts = [
        { x: s.x, y: s.y },
        { x: s.x + s.w, y: s.y },
        { x: s.x, y: s.y + s.h },
        { x: s.x + s.w, y: s.y + s.h },
      ];
      return pts.some((pt) => pointInPoly(pt, poly));
    }
    if (s.mode === "raster") {
      if (!s.runs.length) return false;
      if (!s._bbox) updateRasterBBox(s);
      const { x, y, w, h } = s._bbox;
      return polyIntersectsRect(poly, x, y, w, h);
    }
    return s.points.some((pt) => pointInPoly(pt, poly));
  }
  function cloneStroke(s) {
    if (s.mode === "image") return { ...s };
    if (s.mode === "raster")
      return { ...s, runs: s.runs.map((r) => ({ ...r })) };
    return { ...s, points: s.points.map((p) => ({ ...p })) };
  }
  function bboxOfStroke(s) {
    if (s.mode === "image") {
      return { x: s.x, y: s.y, w: s.w, h: s.h };
    }
    if (s.mode === "raster") {
      if (s._bbox) return { ...s._bbox };
      if (!s.runs.length) return { x: 0, y: 0, w: 0, h: 0 };
      updateRasterBBox(s);
      return { ...s._bbox };
    }
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const p of s.points) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }
  function hexToRgb(hex) {
    const n = parseInt(hex.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
  }

  function eraseRasterStroke(s, cx, cy, rad) {
    const out = [];
    const r2 = rad * rad;
    const rh = s.rowH ?? 1;
    for (const run of s.runs) {
      const top = run.y;
      const bottom = run.y + rh;
      let dy = 0;
      if (cy < top) dy = top - cy;
      else if (cy > bottom) dy = cy - bottom;
      if (dy > rad) {
        out.push(run);
        continue;
      }
      const dx = Math.sqrt(r2 - dy * dy);
      const cutL = Math.floor(cx - dx);
      const cutR = Math.ceil(cx + dx);
      if (run.x1 < cutL || run.x0 > cutR) {
        out.push(run);
        continue;
      }
      if (run.x0 < cutL) {
        const l = { y: run.y, x0: run.x0, x1: cutL - 1, color: run.color };
        if (l.x0 <= l.x1) out.push(l);
      }
      if (run.x1 > cutR) {
        const r = { y: run.y, x0: cutR + 1, x1: run.x1, color: run.color };
        if (r.x0 <= r.x1) out.push(r);
      }
    }
    s.runs = out;
  }

  function updateRasterBBox(s) {
    const rh = s.rowH ?? 1;
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const r of s.runs) {
      if (r.x0 < minX) minX = r.x0;
      if (r.y < minY) minY = r.y;
      if (r.x1 > maxX) maxX = r.x1;
      if (r.y + rh > maxY) maxY = r.y + rh;
    }
    s._bbox =
      minX === Infinity
        ? { x: 0, y: 0, w: 0, h: 0 }
        : { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY };
  }

  function circleIntersectsBBox(cx, cy, r, b) {
    const dx = Math.max(b.x - cx, 0, cx - (b.x + b.w));
    const dy = Math.max(b.y - cy, 0, cy - (b.y + b.h));
    return dx * dx + dy * dy <= r * r;
  }

  function compactRuns(s) {
    s.runs.sort((a, b) => a.y - b.y || a.x0 - b.x0);
    const out = [];
    for (const r of s.runs) {
      const last = out[out.length - 1];
      if (last && last.y === r.y && last.color === r.color && last.x1 >= r.x0 - 1) {
        if (r.x1 > last.x1) last.x1 = r.x1;
      } else out.push(r);
    }
    s.runs = out;
    updateRasterBBox(s);
  }

  function performFill(w) {
    const x = Math.round((w.x - camera.x) * camera.scale * DPR);
    const y = Math.round((w.y - camera.y) * camera.scale * DPR);
    const W = cvs.width,
      H = cvs.height;
    if (x < 0 || y < 0 || x >= W || y >= H) return;
    const img = ctx.getImageData(0, 0, W, H);
    const data = img.data;
    const idx = (y * W + x) * 4;
    const target = [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];
    const mask = new Uint8Array(W * H);
    const stack = [x, y];
    while (stack.length) {
      const yy = stack.pop();
      const xx = stack.pop();
      if (xx < 0 || yy < 0 || xx >= W || yy >= H) continue;
      const mi = yy * W + xx;
      if (mask[mi]) continue;
      const i = mi * 4;
      const a = data[i + 3];
      if (a < 32) continue;
      if (
        Math.abs(data[i] - target[0]) > 24 ||
        Math.abs(data[i + 1] - target[1]) > 24 ||
        Math.abs(data[i + 2] - target[2]) > 24 ||
        Math.abs(a - target[3]) > 24
      )
        continue;
      mask[mi] = 1;
      stack.push(xx + 1, yy, xx - 1, yy, xx, yy + 1, xx, yy - 1);
    }
    const dil = new Uint8Array(W * H);
    for (let yy = 0; yy < H; yy++) {
      for (let xx = 0; xx < W; xx++) {
        const i = yy * W + xx;
        if (mask[i]) {
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = xx + dx,
                ny = yy + dy;
              if (nx >= 0 && ny >= 0 && nx < W && ny < H) dil[ny * W + nx] = 1;
            }
          }
        }
      }
    }
    const off = document.createElement("canvas");
    off.width = W;
    off.height = H;
    const ox = off.getContext("2d");
    const [r, g, b] = hexToRgb(brush.color);
    const outImg = ox.createImageData(W, H);
    for (let i = 0; i < dil.length; i++) {
      if (dil[i]) {
        const j = i * 4;
        outImg.data[j] = r;
        outImg.data[j + 1] = g;
        outImg.data[j + 2] = b;
        outImg.data[j + 3] = 255;
      }
    }
    ox.putImageData(outImg, 0, 0);
    const stroke = window.vectorizeToRasterRuns(off, {
      x: camera.x,
      y: camera.y,
      scale: 1 / (camera.scale * DPR),
    });
    mergeState({ strokes: [stroke] });
    myStack.push(stroke.id);
    const payload = { ...stroke };
    if (payload._bbox) delete payload._bbox;
    Net.sendReliable({ type: "add", stroke: payload });
    requestRender();
    debounceSave();
  }

  function loadImageForStroke(s) {
    const img = new Image();
    img.onload = requestRender;
    img.src = s.data;
    Object.defineProperty(s, "_img", { value: img, enumerable: false });
  }

  // –±–∞—Ç—á–∏–Ω–≥ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
  const buffer = [];
  let flushTimer = null;
  function enqueue(op) {
    buffer.push(op);
    if (!flushTimer) {
      flushTimer = setTimeout(() => {
        Net.sendReliable({
          type: "batch",
          ops: buffer.splice(0, buffer.length),
        });
        flushTimer = null;
      }, 20);
    }
  }

  // –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä
  let rerender = false;
  function requestRender() {
    rerender = true;
  }
  function loop() {
    if (rerender) {
      draw();
      rerender = false;
    }
    requestAnimationFrame(loop);
  }
  loop();
  function draw() {
    const vw = cvs.width / DPR,
      vh = cvs.height / DPR;
    ctx.clearRect(0, 0, vw, vh);
    for (const s of strokes.values()) {
      if (s.mode === "image") {
        if (s._img) {
          const prevSmooth = ctx.imageSmoothingEnabled;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(
            s._img,
            (s.x - camera.x) * camera.scale,
            (s.y - camera.y) * camera.scale,
            s.w * camera.scale,
            s.h * camera.scale,
          );
          ctx.imageSmoothingEnabled = prevSmooth;
        }
        continue;
      }
      if (s.mode === "raster") {
        if (!s._bbox) updateRasterBBox(s);
        const scale = camera.scale;
        const vx1 = vw,
          vy1 = vh;
        const bx0 = (s._bbox.x - camera.x) * scale;
        const by0 = (s._bbox.y - camera.y) * scale;
        const bx1 = (s._bbox.x + s._bbox.w - camera.x) * scale;
        const by1 = (s._bbox.y + s._bbox.h - camera.y) * scale;
        if (bx1 < 0 || bx0 > vx1 || by1 < 0 || by0 > vy1) continue;
        let last = "";
        for (const r of s.runs) {
          if (r.color !== last) {
            ctx.fillStyle = r.color;
            last = r.color;
          }
          // –ª–µ–≤–∞—è/–≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã ‚Äî floor; –ø—Ä–∞–≤–∞—è/–Ω–∏–∂–Ω—è—è ‚Äî ceil —Å —É—á—ë—Ç–æ–º –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ü–∞
          const x0p = Math.floor((r.x0 - camera.x) * scale);
          const x1p = Math.ceil((r.x1 + 1 - camera.x) * scale);
          const y0p = Math.floor((r.y - camera.y) * scale);
          const y1p = Math.ceil((r.y + (s.rowH ?? 1) - camera.y) * scale);
          if (x1p < 0 || x0p > vx1 || y1p < 0 || y0p > vy1) continue;
          const rw = Math.max(1, x1p - x0p);
          const rh = Math.max(1, y1p - y0p);
          ctx.fillRect(x0p, y0p, rw, rh);
        }
        continue;
      }
      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      setCompositeForTool(ctx, s.mode);
      ctx.strokeStyle = s.mode === "erase" ? "#000000" : s.color;
      ctx.lineWidth = s.size * camera.scale;
      ctx.beginPath();
      s.points.forEach((p, i) => {
        const x = (p.x - camera.x) * camera.scale,
          y = (p.y - camera.y) * camera.scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.restore();
    }
    if (selection) drawSel(selection.path, selection.rect, true);
    if (selectionPreview)
      drawSel(selectionPreview, bboxOfPoints(selectionPreview), false);
    if (selection || selectionPreview) requestRender();
    // –∫—É—Ä—Å–æ—Ä—ã
    const now = Date.now();
    for (const [id, c] of cursors) {
      if (now - c.ts > 3000) continue;
      const x = (c.x - camera.x) * camera.scale;
      const y = (c.y - camera.y) * camera.scale;
      const col = cursorsMeta.get(id)?.color || "#007aff";
      drawPeerCursor(x, y, col);
    }
  }

  function drawSel(path, rect, handles) {
    ctx.save();
    ctx.beginPath();
    path.forEach((p, i) => {
      const x = (p.x - camera.x) * camera.scale,
        y = (p.y - camera.y) * camera.scale;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.save();
    const t = (Date.now() / 150) % 8;
    ctx.translate(-t, -t);
    ctx.fillStyle = selPattern;
    ctx.fill();
    ctx.restore();
    ctx.strokeStyle = cursorColor;
    ctx.setLineDash([8, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
    if (handles) {
      const x = (rect.x - camera.x) * camera.scale,
        y = (rect.y - camera.y) * camera.scale,
        w = rect.w * camera.scale,
        h = rect.h * camera.scale;
      const hs = 6;
      const corners = [
        [x, y],
        [x + w, y],
        [x, y + h],
        [x + w, y + h],
      ];
      ctx.fillStyle = "#fff";
      ctx.strokeStyle = cursorColor;
      for (const [cx, cy] of corners) {
        ctx.beginPath();
        ctx.rect(cx - hs / 2, cy - hs / 2, hs, hs);
        ctx.fill();
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  function drawPeerCursor(x, y, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((-20 * Math.PI) / 180);
    ctx.scale(1.5, 1.5);
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.shadowColor = "rgba(0,0,0,0.2)";
    ctx.shadowBlur = 2;
    const r = 4;
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = ((i * 72 - 90) * Math.PI) / 180;
      const x1 = Math.cos(a) * r;
      const y1 = Math.sin(a) * r;
      ctx.lineTo(x1, y1);
      const a2 = a + (36 * Math.PI) / 180;
      ctx.lineTo((Math.cos(a2) * r) / 2, (Math.sin(a2) * r) / 2);
    }
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, 10);
    ctx.stroke();
    ctx.restore();
  }

  // —Å–µ—Ç–µ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  function handleMsg(op) {
    if (op.type === "batch") {
      for (const a of op.ops) handleMsg(a);
      return;
    }
    if (op.type === "stroke_pts") {
      let s = strokes.get(op.id);
      if (!s) {
        s = {
          id: op.id,
          by: op.by,
          mode: op.mode || op.tool,
          color: op.color,
          size: op.size,
          points: [],
        };
        strokes.set(op.id, s);
        cache.set(op.id, s);
        deleted.delete(op.id);
      }
      for (const p of op.points) s.points.push(p);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "presence") {
      cursorsMeta.set(op.id, { color: op.cursorColor || "#007aff" });
      return;
    }
    if (op.type === "fill") {
      const s = {
        id: op.id,
        by: op.by,
        mode: "fill",
        color: op.color,
        size: 0,
        points: [{ x: op.x, y: op.y }],
      };
      strokes.set(op.id, s);
      cache.set(op.id, s);
      deleted.delete(op.id);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "del") {
      strokes.delete(op.id);
      deleted.add(op.id);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "add") {
      const s = op.stroke;
      if (s.mode === "image") loadImageForStroke(s);
      strokes.set(s.id, s);
      cache.set(s.id, s);
      deleted.delete(s.id);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "state_req") {
      if (op.id) {
        Net.sendReliableTo(op.id, {
          type: "state_full",
          state: serializeState(),
        });
      } else {
        // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π (—Å—Ç–∞—Ä—ã–µ –∫–ª–∏–µ–Ω—Ç—ã) ‚Äî —à–∏—Ä–æ–∫–æ–≤–µ—â–∞—Ç–µ–ª—å–Ω–æ
        Net.sendReliable({
          type: "state_full",
          state: serializeState(),
        });
      }
      return;
    }
    if (op.type === "state_full") {
      if (op.state) mergeState(op.state);
      return;
    }
  }

  function serializeState() {
  // –í–ê–ñ–ù–û: –Ω–µ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏–º –∑–¥–µ—Å—å ‚Äî –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—É—â–µ–µ
  const out = [];
  for (const s of strokes.values()) {
    const copy = { ...s };
    // —É–±–∏—Ä–∞–µ–º –∫—ç—à–µ–≤—ã–µ/–Ω–µ —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã–µ –ø–æ–ª—è
    delete copy._bbox;
    delete copy._img;
    out.push(copy);
  }
  return {
    bg: bgColor,
    strokes: out,
    rev,
    deleted: [...deleted], // –ø–æ–¥–¥–µ—Ä–∂–∫–∞ soft-delete
  };
}
  function mergeState(state, opt = {}) {
    try {
      let changed = false;
      if (state && typeof state.bg === "string") {
        bgColor = state.bg;
        drawGrid();
      }
      if (state && Array.isArray(state.strokes)) {
        for (const s of state.strokes) {
          if (s.mode === "raster") compactRuns(s);
          const had = strokes.get(s.id);
          if (!had) {
            if (s.mode === "image") loadImageForStroke(s);
            strokes.set(s.id, s);
            cache.set(s.id, s);
            deleted.delete(s.id);
            changed = true;
          } else if (
            s.mode === "image" ||
            s.mode === "raster" ||
            (had.points?.length || 0) < (s.points?.length || 0)
          ) {
            if (s.mode === "image" && had.mode === "image") {
              const sigHad = `${had.w}x${had.h}:${had.src?.length || 0}`;
              const sigNew = `${s.w}x${s.h}:${s.src?.length || 0}`;
              if (sigHad === sigNew) continue;
            }
            if (s.mode === "raster" && had.mode === "raster") {
              const sigHad = `${had.runs.length}:${had.rowH ?? 1}`;
              const sigNew = `${s.runs.length}:${s.rowH ?? 1}`;
              if (sigHad === sigNew) continue;
            }
            if (s.mode === "image") loadImageForStroke(s);
            strokes.set(s.id, s);
            cache.set(s.id, s);
            deleted.delete(s.id);
            changed = true;
          }
        }
      }
      if (state && Array.isArray(state.deleted)) {
        for (const id of state.deleted) {
          strokes.delete(id);
          deleted.add(id);
        }
        if (state.deleted.length) changed = true;
      }
      // –ø–æ–¥–Ω—è—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é —Ä–µ–≤–∏–∑–∏—é –¥–æ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π/—á—É–∂–æ–π
      const srvRev = state && typeof state.rev === "number" ? state.rev | 0 : 0;
      if (srvRev > rev) setRev(srvRev);
      requestRender();
      // –í–ê–ñ–ù–û:
      // - –µ—Å–ª–∏ —ç—Ç–æ —Å–µ—Ä–≤–µ—Ä–Ω—ã–π state ‚Üí –ù–ï —Å–æ—Ö—Ä–∞–Ω—è–µ–º (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø–µ—Ç–ª–∏)
      // - –µ—Å–ª–∏ —ç—Ç–æ peer state_full (opt.fromServer=false) –∏–ª–∏ –ª–æ–∫–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ ‚Üí —Å–æ—Ö—Ä–∞–Ω—è–µ–º
      if (!opt.fromServer && changed) debounceSave();
      return changed;
    } catch (e) {}
  }

  Object.assign(window, {
    cvs,
    grid,
    strokes,
    cache,
    myStack,
    camera,
    get DPR() {
      return DPR;
    },
    get meId() {
      return meId;
    },
    serializeState,
    mergeState,
    screenToWorld,
    requestRender,
    debounceSave,
    genId,
  });

  // undo/redo
  function undo() {
    const id = myStack.pop();
    if (!id) return;
    Net.sendReliable({ type: "del", id });
    strokes.delete(id);
    deleted.add(id);
    redoStack.push(id);
    requestRender();
    debounceSave();
  }
  function redo() {
    const id = redoStack.pop();
    if (!id) return;
    const s = cache.get(id);
    if (!s) return;
    strokes.set(id, s);
    deleted.delete(id);
    const payload = { ...s };
    if (payload._bbox) delete payload._bbox;
    Net.sendReliable({ type: "add", stroke: payload });
    myStack.push(id);
    requestRender();
    debounceSave();
  }

  // PNG —ç–∫—Å–ø–æ—Ä—Ç
  async function exportPNG() {
    if (strokes.size === 0) {
      alert("–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å");
      return;
    }
    const blob = await exportEmbeddedPNG();
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "canvas.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function leaveRoom() {
    Net.disconnect();
    stopPing();
    setRev(0);
    roomId = null;
    strokes.clear();
    cache.clear();
    myStack.length = 0;
    redoStack.length = 0;
    deleted.clear();
    if (pullTimer) {
      clearTimeout(pullTimer);
      pullTimer = null;
    }
    document.getElementById("stage").style.display = "none";
    document.getElementById("toolbar").style.display = "none";
    document.getElementById("lobby").style.display = "block";
    document.documentElement.style.setProperty("--stage-bottom-inset", "0px");
    resize();
    renderRooms();
  }

  // –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ü–∏—è + —Å–µ—Ä–≤–µ—Ä–Ω–∞—è
  function saveLocal() {
    try {
      localStorage.setItem("room:" + roomId, JSON.stringify(serializeState()));
    } catch {}
  }
  function loadLocal() {
    try {
      const j = localStorage.getItem("room:" + roomId);
      if (j) {
        const s = JSON.parse(j);
        if (s) mergeState(s);
      }
    } catch {}
  }
  let saveTimer = null;
  function debounceSave() {
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      saveTimer = null;
      setRev((rev | 0) + 1);
      saveLocal();
      Net.saveState(serializeState());
    }, 700);
  }

  let pullTimer = null,
    lastPull = 0;
  function schedulePull() {
    if (pullTimer) return;
    const now = Date.now();
    const wait = Math.max(0, 500 - (now - lastPull));
    pullTimer = setTimeout(() => {
      pullTimer = null;
      lastPull = Date.now();
      try {
        Net.requestState();
      } catch {}
    }, wait);
  }
  window.schedulePull = schedulePull;

  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      // –ø–æ–¥–Ω–∏–º–µ–º —Ä–µ–≤–∏–∑–∏—é –∏ —Å–æ—Ö—Ä–∞–Ω–∏–º
      setRev((rev | 0) + 1);
      Net.saveState(serializeState());
    }
  });

  window.addEventListener("beforeunload", () => {
    try {
      setRev((rev | 0) + 1);
      Net.saveState(serializeState());
    } catch {}
  });
</script>
