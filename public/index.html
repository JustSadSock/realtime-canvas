<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Realtime Canvas</title>
<style>
  :root {
    --bg: #fff9fb;
    --stage-bottom-inset: 0px; /* –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è –∫–∞–Ω–≤–∞—Å–∞ */
    --fg: #222;
    --border: #e0cfe4;
    --panel: #ffffffcc;
    --muted: #888;
    --accent: #ff99cc;
  }
  html,
  body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--fg);
    font-family:
      system-ui,
      -apple-system,
      Segoe UI,
      Roboto,
      Arial;
  }
  body.in-stage {
    overflow: hidden;
  }
  .wrap {
    max-width: 800px;
    margin: 20px auto;
    padding: 16px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: #fff;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
  }
  input,
  button,
  select {
    background: #fff;
    color: var(--fg);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 16px;
    touch-action: manipulation;
  }
  input[type="range"] {
    padding: 0;
  }
  button {
    cursor: pointer;
    transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
    background: linear-gradient(#fff, #e6e6e6);
  }
  button:active {
    transform: scale(0.98);
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
  }
  button:hover {
    background: var(--accent);
    color: #fff;
  }
  .tool {
    transition: transform 0.08s, opacity 0.08s;
  }
  .tool.active {
    transform: scale(1.08);
  }
  button.active,
  .swatch.active,
  #color.active {
    box-shadow: 0 0 0 3px var(--accent);
  }
  .sz.active {
    outline: 2px solid var(--accent);
    box-shadow: none;
  }
  .row {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin: 0.5rem 0;
  }
  #rooms {
    display: grid;
    gap: 8px;
    margin-top: 8px;
  }
  #rooms .room {
    padding: 8px;
    border: 1px solid var(--border);
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.2s;
  }
  #rooms .room:hover {
    background: var(--panel);
  }
  #rooms .room .hide {
    margin-left: 8px;
    cursor: pointer;
    background: none;
    border: none;
  }
  #stage {
    position: fixed;
    inset: 0;
    display: none;
  }
  #grid {
    position: absolute;
    inset: 0;
    bottom: var(--stage-bottom-inset, 0px); /* –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Å–µ—Ç–∫–∏ */
    pointer-events: none;
  }
  #cvs {
    position: absolute;
    inset: 0;
    bottom: var(--stage-bottom-inset, 0px); /* –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Ö–æ–ª—Å—Ç–∞ */
    touch-action: none;
  }
  /* –°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –ª–æ–±–±–∏ */
  #toolbar {
    display: none;
  }
  #toolbar .group {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  #toolbar .dropdown {
    position: relative;
  }
  #toolbar .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    flex-direction: column;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 6px;
    gap: 6px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }
  #toolbar .dropdown.open .dropdown-menu {
    display: flex;
  }
  #toolbar .swatch {
    width: 26px;
    height: 26px;
    border-radius: 6px;
    border: 1px solid var(--border);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  #toolbar .wand {
    display: inline-block;
    transform: rotate(-20deg) scale(1.5);
  }
  #toolbar small {
    color: var(--muted);
  }
  #latency-badge {
    position: fixed;
    top: env(safe-area-inset-top, 8px);
    right: 8px;
    padding: 6px 10px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.55);
    color: #fff;
    font:
      13px/1.2 system-ui,
      sans-serif;
    z-index: 1100; /* –≤—ã—à–µ —Ç—É–ª–±–∞—Ä–∞ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ */
    backdrop-filter: blur(6px);
  }

  /* Desktop: top full-width, –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ */
  @media (min-width: 769px) and (pointer: fine) {
    #toolbar[data-show="1"] {
      position: fixed;
      top: 8px;
      left: 8px;
      right: 8px;
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      padding: 8px 10px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      z-index: 1001;
    }
  }

  /* Mobile: bottom full-width, –ø–µ—Ä–µ–Ω–æ—Å –≤ 2 —Å—Ç—Ä–æ–∫–∏ –ø—Ä–∏ –Ω–µ—Ö–≤–∞—Ç–∫–µ –º–µ—Å—Ç–∞ */
  @media (max-width: 768px), (pointer: coarse) {
    #toolbar[data-show="1"] {
      position: fixed;
      left: 0;
      right: 0;
      bottom: calc(env(safe-area-inset-bottom, 0) + 8px);
      display: flex;
      flex-wrap: wrap;
      gap: 8px 8px;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
      z-index: 1001;
    }
    #toolbar .dropdown-menu {
      top: auto;
      bottom: 100%; /* –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≤–≤–µ—Ä—Ö */
      left: 0;
    }
    /* –ì—Ä—É–ø–ø—ã –∏ –∫–Ω–æ–ø–∫–∏ ‚Äî –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ –∏ –Ω–µ –∫—Ä–æ—à–∞—Ç—Å—è */
    #toolbar .group {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      flex: 0 1 auto;
    }
    #toolbar button,
    #toolbar .tool {
      min-width: 44px;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
    }
    .hint {
      display: none;
    }
    canvas {
      block-size: auto;
    }
  }
  /* –ñ–µ—Å—Ç—ã –∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ ‚Äî —Ç–æ–ª—å–∫–æ –Ω–∞—à–∏–º–∏ —Ä—É–∫–∞–º–∏ */
  canvas {
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
  }
  .hint {
    position: fixed;
    right: 8px;
    bottom: 8px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 6px 8px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }
</style>

<div id="lobby" class="wrap">
  <h2>–ö–æ–º–Ω–∞—Ç—ã</h2>
  <div class="row">
    <input id="room" placeholder="id –∫–æ–º–Ω–∞—Ç—ã" style="flex: 1" />
    <button id="create">–°–æ–∑–¥–∞—Ç—å</button>
    <button id="join">–í–æ–π—Ç–∏</button>
  </div>
  <div class="row"><button id="refresh">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫</button></div>
  <div id="rooms"></div>
</div>

<div id="stage">
  <canvas id="grid"></canvas>
  <canvas id="cvs"></canvas>
</div>

<div id="latency-badge" aria-live="polite" hidden>‚Äî ms</div>

<div id="toolbar">
  <div class="group">
    <button id="tool-draw" class="tool" title="–ö–∏—Å—Ç—å">‚úèÔ∏è</button>
    <button id="tool-erase" class="tool" title="–õ–∞—Å—Ç–∏–∫">ü©π</button>
    <div id="more-group" class="dropdown">
      <button id="tool-more" title="–î—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã">‚ãØ</button>
      <div id="more-menu" class="dropdown-menu">
        <button id="tool-select" class="tool" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">
          <span class="wand">ü™Ñ</span>
        </button>
        <button id="tool-fill" class="tool" title="–ó–∞–ª–∏–≤–∫–∞">ü™£</button>
        <button id="tool-pipette" class="tool" title="–ü–∏–ø–µ—Ç–∫–∞">üß™</button>
      </div>
    </div>
  </div>
  <div class="group">
    <small>–¢–æ–ª—â–∏–Ω–∞</small>
    <button class="sz" data-v="2" aria-pressed="false" aria-label="–†–∞–∑–º–µ—Ä 2">2</button>
    <button class="sz" data-v="6" aria-pressed="false" aria-label="–†–∞–∑–º–µ—Ä 6">6</button>
    <button class="sz" data-v="12" aria-pressed="false" aria-label="–†–∞–∑–º–µ—Ä 12">12</button>
    <button class="sz" data-v="24" aria-pressed="false" aria-label="–†–∞–∑–º–µ—Ä 24">24</button>
    <input id="size" type="range" min="1" max="40" value="6" title="—Ç–æ–ª—â–∏–Ω–∞" />
  </div>
  <div class="group">
    <small>–¶–≤–µ—Ç</small>
    <button
      class="col swatch"
      data-c="#000000"
      style="background: #000"
    ></button>
    <button
      class="col swatch"
      data-c="#ff3b30"
      style="background: #ff3b30"
    ></button>
    <button
      class="col swatch"
      data-c="#34c759"
      style="background: #34c759"
    ></button>
    <button
      class="col swatch"
      data-c="#007aff"
      style="background: #007aff"
    ></button>
    <input
      id="color"
      class="col"
      type="color"
      value="#000000"
      title="—Ü–≤–µ—Ç –∫–∏—Å—Ç–∏"
    />
  </div>
  <div class="group">
    <button id="undo" title="–û—Ç–º–µ–Ω–∏—Ç—å">‚Ü∂</button>
    <button id="redo" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å">‚Ü∑</button>
    <button id="export" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å PNG">üñºÔ∏è PNG</button>
    <button id="import" title="–ò–º–ø–æ—Ä—Ç PNG">üì• Import</button>
    <button id="leave" title="–í—ã–π—Ç–∏ –≤ –ª–æ–±–±–∏">üè†</button>
    <button id="settingsBtn" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öôÔ∏è</button>
  </div>
</div>

<div id="img-actions" style="display:none;position:fixed;top:52px;left:50%;transform:translateX(-50%);z-index:1102;gap:4px;">
  <button id="img-place" title="–†–∞–∑–º–µ—Å—Ç–∏—Ç—å" aria-label="–†–∞–∑–º–µ—Å—Ç–∏—Ç—å">‚úÖ</button>
  <button id="img-cancel" title="–û—Ç–º–µ–Ω–∏—Ç—å" aria-label="–û—Ç–º–µ–Ω–∏—Ç—å">‚úñÔ∏è</button>
</div>
<div id="import-hint" style="display:none;position:fixed;left:50%;top:80px;transform:translateX(-50%);font-size:12px;color:var(--muted);z-index:1000;">—â–∏–ø–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å</div>
<style>
@media (max-width:768px), (pointer:coarse){
  #img-actions{
    top:auto; bottom:calc(env(safe-area-inset-bottom, 0) + 88px);
  }
  #import-hint{
    top:auto; bottom:calc(env(safe-area-inset-bottom, 0) + 120px);
  }
}
</style>

<input id="imageLoader" type="file" accept="image/png" style="display: none" />

<div class="hint" id="hint">
  1-5: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã ‚Ä¢ 6-9: —Ä–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏ ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ:
  –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
</div>

<div
  id="settings"
  class="wrap"
  style="
    display: none;
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000; /* –º–æ–¥–∞–ª–∫–∞ –Ω–∞–¥ —Ç—É–ª–±–∞—Ä–æ–º */
    background: #fff;
    max-width: 400px;
  "
>
  <h2>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
  <div class="row" style="flex-direction: column; gap: 4px">
    <label>–¶–≤–µ—Ç —Ñ–æ–Ω–∞ <input id="bg" type="color" value="#ffffff" /></label>
    <label
      >–¶–≤–µ—Ç —Å–µ—Ç–∫–∏ <input id="gridColor" type="color" value="#cccccc"
    /></label>
    <label
      >–¶–≤–µ—Ç –∫—É—Ä—Å–æ—Ä–∞ <input id="cursorColorInput" type="color" value="#007aff"
    /></label>
    <label
      >–ö–∏—Å—Ç—å <input class="hk" data-action="draw" value="1" size="2"
    /></label>
    <label
      >–õ–∞—Å—Ç–∏–∫ <input class="hk" data-action="erase" value="2" size="2"
    /></label>
    <label
      >–í—ã–¥–µ–ª–µ–Ω–∏–µ <input class="hk" data-action="select" value="3" size="2"
    /></label>
    <label
      >–ó–∞–ª–∏–≤–∫–∞ <input class="hk" data-action="fill" value="5" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 2 <input class="hk" data-action="size2" value="6" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 6 <input class="hk" data-action="size6" value="7" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 12 <input class="hk" data-action="size12" value="8" size="2"
    /></label>
    <label
      >–†–∞–∑–º–µ—Ä 24 <input class="hk" data-action="size24" value="9" size="2"
    /></label>
    <label class="row">
      <input type="checkbox" id="opt-latency" /> –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É —Å–µ—Ä–≤–µ—Ä–∞
    </label>
  </div>
  <div class="row"><button id="settingsClose">–ó–∞–∫—Ä—ã—Ç—å</button></div>
</div>

<script type="module" src="embed-png.js"></script>
<script>
  window.schedulePull ||= function () {};
</script>
<script src="net-webrtc.js"></script>
<script type="module">
  import { exportEmbeddedPNG } from "./embed-png.js";
  // ===== app state (—Å–æ–∑–¥–∞—Ç—å –î–û –ª—é–±—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π) =====
  const app = {
    ready: false,

    DPR: 1,
    bgColor: "#ffffff",

    grid: null,
    gtx: null,
    cvs: null,
    ctx: null,

    camera: { x: 0, y: 0, scale: 1 },

    importActive: false,
    gridColor: "#cccccc",
  };

  // ===== util =====
  const $ = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));
  const genId = () => `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

  function isMobileUI() {
    return matchMedia("(max-width: 768px), (pointer: coarse)").matches;
  }
  function getStageInsetPx() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--stage-bottom-inset",
    );
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : 0;
  }
  function adjustBottomInset() {
    if (!app.ctx) return; // guard
    const tb = document.getElementById("toolbar");
    if (!tb) {
      return;
    }
    // —Å—á–∏—Ç–∞–µ–º –∏–Ω—Å–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Ç—É–ª–±–∞—Ä –≤–∏–¥–µ–Ω –∏ –º—ã –≤ –º–æ–±–∏–ª—å–Ω–æ–π —Ä–∞—Å–∫–ª–∞–¥–∫–µ
    let inset = 0;
    if (isMobileUI() && tb.dataset.show === "1") {
      const h = tb.getBoundingClientRect().height; // 1 –∏–ª–∏ 2 —Å—Ç—Ä–æ–∫–∏
      inset = Math.ceil(h + 8);
    }
    // –¥–≤–∏–≥–∞–µ–º –Ω–∏–∑ —Ö–æ–ª—Å—Ç–∞ –∏ —Å–µ—Ç–∫–∏
    document.documentElement.style.setProperty(
      "--stage-bottom-inset",
      inset + "px",
    );
    // –ø–µ—Ä–µ—Å—á—ë—Ç —Ä–∞–∑–º–µ—Ä–æ–≤ –∫–∞–Ω–≤–∞—Å–æ–≤ –ø–æ–¥ –Ω–æ–≤—ã–π –∏–Ω—Å–µ—Ç
    resize();
  }

  function resize() {
    if (!app.ctx || !app.gtx) return; // guard

    const dpr = Math.max(1, devicePixelRatio || 1);
    app.DPR = dpr;

    const w = innerWidth;
    const inset = isMobileUI() ? getStageInsetPx() : 0;
    const h = Math.max(0, innerHeight - inset);

    for (const cn of [app.grid, app.cvs]) {
      cn.width = w * dpr;
      cn.height = h * dpr;
      cn.style.width = w + "px";
      cn.style.height = h + "px";
    }
    app.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    app.gtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    drawGrid();
    requestRender();
  }

  function setCompositeForTool(context, tool) {
    context.globalCompositeOperation =
      tool === "erase" ? "destination-out" : "source-over";
  }

  function drawGrid() {
    if (!app.gtx || !app.grid) return; // guard

    const w = app.grid.width / app.DPR,
      h = app.grid.height / app.DPR;
    app.gtx.fillStyle =
      typeof app.bgColor === "string" ? app.bgColor : "#ffffff";
    app.gtx.fillRect(0, 0, w, h);
    const step = 100 * app.camera.scale;
    if (step > 24) {
      app.gtx.strokeStyle = app.gridColor;
      app.gtx.lineWidth = 1;
      const sx = -((app.camera.x * app.camera.scale) % step),
        sy = -((app.camera.y * app.camera.scale) % step);
      app.gtx.beginPath();
      for (let x = sx; x < w; x += step) {
        app.gtx.moveTo(x, 0);
        app.gtx.lineTo(x, h);
      }
      for (let y = sy; y < h; y += step) {
        app.gtx.moveTo(0, y);
        app.gtx.lineTo(w, y);
      }
      app.gtx.stroke();
    }
  }

  function boot() {
    if (app.ready) return; // –∑–∞—â–∏—Ç–∏–º—Å—è –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
    // –ü—Ä–∏–≤—è–∑–∫–∏ DOM –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
    app.grid = document.getElementById("grid");
    app.gtx = app.grid.getContext("2d");
    app.cvs = document.getElementById("cvs");
    app.cvs.style.touchAction = "none";
    app.ctx = app.cvs.getContext("2d");

    // –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫/–≥–æ—Ä—è—á–∏—Ö –∫–ª–∞–≤–∏—à/—Ü–≤–µ—Ç–æ–≤ –∏ —Ç.–ø.
    loadSettings?.();
    updateSelPattern();
    renderHint();
    setTool(mode);
    setSize(brush.size);
    setColor(brush.color, $("#color"));

    // –ù–∞–≤–µ—Å–∏—Ç—å —Å–ª—É—à–∞—Ç–µ–ª–∏ –¢–û–õ–¨–ö–û —Å–µ–π—á–∞—Å
    addEventListener("resize", resize, { passive: true });

    app.cvs.addEventListener("dblclick", (e) => e.preventDefault(), {
      passive: false,
    });
    ["gesturestart", "gesturechange", "gestureend"].forEach((evt) =>
      app.cvs.addEventListener(evt, (e) => e.preventDefault(), { passive: false }),
    );
    app.cvs.addEventListener("pointerdown", onPointerDown);
    app.cvs.addEventListener("pointermove", onPointerMove);
    app.cvs.addEventListener("pointerup", onPointerUp);
    app.cvs.addEventListener("pointercancel", onPointerCancel);
    app.cvs.addEventListener("wheel", onWheel, { passive: false });
    app.cvs.addEventListener("contextmenu", (e) => e.preventDefault());

    if ("ResizeObserver" in window) {
      new ResizeObserver(adjustBottomInset).observe(
        document.getElementById("toolbar"),
      );
    } else {
      addEventListener("resize", () => setTimeout(adjustBottomInset, 0));
    }
    addEventListener("orientationchange", () =>
      setTimeout(adjustBottomInset, 200),
    );
    {
      const mql = matchMedia("(max-width: 768px), (pointer: coarse)");
      if (mql.addEventListener) {
        mql.addEventListener("change", adjustBottomInset);
      } else if (mql.addListener) {
        mql.addListener(adjustBottomInset);
      }
    }

    // –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –≤–Ω–µ—à–Ω–∏–º–∏ –º–æ–¥—É–ª—è–º–∏
    const d = (get, set) => ({
      get,
      set,
      configurable: true,
      enumerable: true,
    });
    Object.defineProperties(window, {
      camera: d(() => app.camera),
      DPR: d(() => app.DPR),
      importActive: d(() => app.importActive, (v) => (app.importActive = !!v)),
      cvs: d(() => app.cvs),
      grid: d(() => app.grid),
      ctx: d(() => app.ctx),
      gtx: d(() => app.gtx),
    });

    app.ready = true; // –±–∞—Ä—å–µ—Ä –æ–ø—É—Å–∫–∞–µ–º

    // –ü–µ—Ä–≤—ã–π layout –∏ –ø–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä
    adjustBottomInset();
    requestRender();
    if (typeof loop === "function") requestAnimationFrame(loop);
  }

  // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫: –µ—Å–ª–∏ DOM –µ—â—ë –≥—Ä—É–∑–∏—Ç—Å—è ‚Äî –∂–¥—ë–º, –∏–Ω–∞—á–µ ‚Äî –º–∏–∫—Ä–æ—Ç–∞—Å–∫,
  // —á—Ç–æ–±—ã –≤—Å–µ let-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–Ω–∞–ø—Ä. cursorColor) —É—Å–ø–µ–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è.
  if (document.readyState === "loading")
    document.addEventListener("DOMContentLoaded", boot, { once: true });
  else queueMicrotask(boot);

  // ===== state =====
  let roomId = null,
    meId = null; // –º–æ–π peer id
  let rev = 0; // —Ä–µ–≤–∏–∑–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è (–º–æ–Ω–æ—Ç–æ–Ω–Ω–æ —Ä–∞—Å—Ç—ë—Ç)
  window.rev = rev;
  function setRev(v) {
    rev = v | 0;
    window.rev = rev;
  }
  let mode = "draw";
  let brush = { color: "#000000", size: 6 };
  let selection = null,
    selOp = null,
    selectionPreview = null;
  let selRAF = 0;
  let cursorColor = "#007aff";
  const defaultHotkeys = {
    draw: "1",
    erase: "2",
    select: "3",
    fill: "5",
    size2: "6",
    size6: "7",
    size12: "8",
    size24: "9",
  };
  let hotkeys = { ...defaultHotkeys };
  function loadSettings() {
    try {
      const s = JSON.parse(localStorage.getItem("settings"));
      if (s) {
        if (s.hotkeys) Object.assign(hotkeys, s.hotkeys);
        if (s.cursorColor) cursorColor = s.cursorColor;
      }
    } catch {}
  }
  function saveSettings() {
    try {
      localStorage.setItem(
        "settings",
        JSON.stringify({ hotkeys, cursorColor }),
      );
    } catch {}
  }
  function sendPresence() {
    if (meId == null) return;
    cursorsMeta.set(meId, { color: cursorColor });
    Net.sendReliable({ type: "presence", cursorColor });
  }
  // –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã –≤ boot()
  function renderHint() {
    $("#hint").textContent =
      `–ö–∏—Å—Ç—å: ${hotkeys.draw} ‚Ä¢ –õ–∞—Å—Ç–∏–∫: ${hotkeys.erase} ‚Ä¢ –í—ã–¥–µ–ª–µ–Ω–∏–µ: ${hotkeys.select} ‚Ä¢ –ó–∞–ª–∏–≤–∫–∞: ${hotkeys.fill} ‚Ä¢ –†–∞–∑–º–µ—Ä: ${hotkeys.size2}/${hotkeys.size6}/${hotkeys.size12}/${hotkeys.size24} ‚Ä¢ –ö–æ–ª—ë—Å–∏–∫–æ: –∑—É–º ‚Ä¢ Shift+–∫–æ–ª—ë—Å–∏–∫–æ: –ø–∞–Ω–æ—Ä–∞–º–∞ ‚Ä¢ Shift –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ: —Ñ–∏–∫—Å–∏—Ä—É–µ—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–∏ ‚Ä¢ –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞: –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ`;
  }

  const strokes = new Map(); // id-> {id,by,mode,...}
  const cache = new Map(); // –ø–æ–ª–Ω—ã–π —à—Ç—Ä–∏—Ö (–¥–ª—è redo/—Ä–µ—Å–∏–Ω–∫–∞)
  const myStack = []; // ids –º–æ–∏—Ö —à—Ç—Ä–∏—Ö–æ–≤ (–¥–ª—è undo)
  const redoStack = []; // ids –¥–ª—è redo
  const rasterDirty = new Set();
  const deleted = new Set();


  const patternCanvas = document.createElement("canvas");
  patternCanvas.width = 8;
  patternCanvas.height = 8;
  const ptx = patternCanvas.getContext("2d");
  let selPattern = null;
  // Requires app.ctx; call only after boot() initializes contexts
  function updateSelPattern() {
    if (!app?.ctx) return;
    ptx.clearRect(0, 0, 8, 8);
    ptx.strokeStyle = cursorColor;
    ptx.lineWidth = 1;
    ptx.beginPath();
    ptx.moveTo(0, 0);
    ptx.lineTo(8, 8);
    ptx.moveTo(0, 8);
    ptx.lineTo(8, 0);
    ptx.stroke();
    selPattern = app.ctx.createPattern(patternCanvas, "repeat");
  }

  function ensureSelAnim(on) {
    if (on && !selRAF) {
      const tick = () => {
        if (!selection) {
          selRAF = 0;
          return;
        }
        requestRender();
        selRAF = requestAnimationFrame(tick);
      };
      selRAF = requestAnimationFrame(tick);
    } else if (!on && selRAF) {
      cancelAnimationFrame(selRAF);
      selRAF = 0;
    }
  }
  // –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–æ –≤ boot() –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞

  // ===== UI wiring =====
  const toolButtons = $$(".tool");
  function setTool(t) {
    mode = t;
    toolButtons.forEach((btn) =>
      btn.classList.toggle("active", btn.id === "tool-" + t),
    );
  }
  $("#tool-draw").onclick = () => { sfx.beep(660, 0.05); setTool("draw"); };
  $("#tool-erase").onclick = () => { sfx.beep(660, 0.05); setTool("erase"); };
  $("#tool-select").onclick = () => { sfx.beep(660, 0.05); setTool("select"); };
  $("#tool-fill").onclick = () => { sfx.beep(660, 0.05); setTool("fill"); };
  $("#tool-pipette").onclick = () => { sfx.beep(660, 0.05); setTool("pipette"); };

  const moreGroup = $("#more-group");
  $("#tool-more").onclick = (e) => {
    e.stopPropagation();
    moreGroup.classList.toggle("open");
  };
  document.addEventListener("click", (e) => {
    if (!moreGroup.contains(e.target)) moreGroup.classList.remove("open");
  });
  $("#more-menu").onclick = () => moreGroup.classList.remove("open");

  const optLatency = document.getElementById("opt-latency");
  const latencyBadge = document.getElementById("latency-badge");
  const LATENCY_KEY = "opt-latency";
  optLatency.checked = JSON.parse(localStorage.getItem(LATENCY_KEY) || "false");
  latencyBadge.hidden = !optLatency.checked;
  optLatency.addEventListener("change", () => {
    localStorage.setItem(LATENCY_KEY, optLatency.checked);
    latencyBadge.hidden = !optLatency.checked;
  });
  let pingTimer = null;
  function startPing() {
    if (pingTimer) return;
    pingTimer = setInterval(sendPing, 5000);
  }
  function stopPing() {
    if (!pingTimer) return;
    clearInterval(pingTimer);
    pingTimer = null;
  }
  function sendPing() {
    if (!optLatency.checked) return;
    const t = performance.now();
    Net.pingServer(t);
  }

  const imageLoader = $("#imageLoader");
  let pendingImage = null;
  let previewDrag = null;
  let imgPinch = null;
  function showPlaceCancelUI(v) {
    $("#img-actions").style.display = v ? "flex" : "none";
    $("#import-hint").style.display = v ? "block" : "none";
  }
  function startImagePreview(img) {
    pendingImage = {
      img,
      x: app.camera.x + 100,
      y: app.camera.y + 100,
      w: img.width,
      h: img.height,
      scale: Math.max(0.05, Math.min(16, 1)),
    };
    app.importActive = true;
    showPlaceCancelUI(true);
    setPreviewHotkeys(true);
    sfx.beep(660, 0.05);
    requestRender();
  }
  function cancelImagePreview() {
    pendingImage = null;
    app.importActive = false;
    showPlaceCancelUI(false);
    setPreviewHotkeys(false);
    sfx.beep(330, 0.05);
    requestRender();
  }
  function placeImagePreview() {
    if (!pendingImage) {
      sfx.beep(220, 0.05);
      return;
    }
    const id = genId();
    const s = {
      id,
      by: meId,
      mode: "image",
      x: pendingImage.x,
      y: pendingImage.y,
      w: pendingImage.w,
      h: pendingImage.h,
      data: pendingImage.img.src,
    };
    strokes.set(id, s);
    cache.set(id, s);
    deleted.delete(id);
    s._img = pendingImage.img;
    Net.sendReliable({ type: "add", stroke: { ...s, _img: undefined } });
    myStack.push(id);
    pendingImage = null;
    app.importActive = false;
    showPlaceCancelUI(false);
    setPreviewHotkeys(false);
    sfx.beep(880, 0.05);
    requestRender();
    debounceSave();
  }
  $("#img-place").onclick = placeImagePreview;
  $("#img-cancel").onclick = cancelImagePreview;
  async function downscaleImage(srcImg, max = 2048) {
    const s = Math.min(1, max / Math.max(srcImg.width, srcImg.height));
    if (s === 1) return srcImg;
    const c = document.createElement("canvas");
    c.width = Math.round(srcImg.width * s);
    c.height = Math.round(srcImg.height * s);
    const x = c.getContext("2d");
    x.imageSmoothingQuality = "high";
    x.drawImage(srcImg, 0, 0, c.width, c.height);
    const out = new Image();
    out.decoding = "async";
    out.src = c.toDataURL("image/png");
    await out.decode().catch(() => {});
    return out;
  }
  function handleImageFile(file) {
    if (!file || !file.type.startsWith("image/")) return;
    const reader = new FileReader();
    reader.onload = async () => {
      const img = new Image();
      img.decoding = "async";
      img.src = reader.result;
      await img.decode().catch(() => {});
      startImagePreview(await downscaleImage(img));
    };
    reader.onerror = () => sfx.beep(220, 0.05);
    reader.readAsDataURL(file);
  }

  const sizeButtons = $$(".sz");
  function setSize(v) {
    brush.size = v;
    $("#size").value = v;
    sizeButtons.forEach((b) => {
      const active = +b.dataset.v === v;
      b.classList.toggle("active", active);
      b.setAttribute("aria-pressed", active);
    });
  }
  $("#size").oninput = (e) => setSize(+e.target.value);
  sizeButtons.forEach((b) => (b.onclick = () => setSize(+b.dataset.v)));

  const colorInputs = $$(".col");
  function setColor(c, el) {
    brush.color = c;
    $("#color").value = c;
    colorInputs.forEach((b) => b.classList.toggle("active", b === el));
  }
  $("#color").oninput = (e) => setColor(e.target.value, $("#color"));
  colorInputs.forEach((b) => (b.onclick = () => setColor(b.dataset.c, b)));
  $("#bg").oninput = (e) => {
    app.bgColor = e.target.value;
    drawGrid();
    requestRender();
    debounceSave();
  };
  $("#gridColor").oninput = (e) => {
    app.gridColor = e.target.value;
    drawGrid();
  };
  $("#undo").onclick = () => { sfx.beep(660, 0.05); undo(); };
  $("#redo").onclick = () => { sfx.beep(660, 0.05); redo(); };
  $("#export").onclick = () => { sfx.beep(660, 0.05); exportPNG(); };
  $("#import").onclick = () => { sfx.beep(660, 0.05); imageLoader.click(); };
  $("#leave").onclick = () => { sfx.beep(660, 0.05); leaveRoom(); };
  $("#settingsBtn").onclick = () => {
    $("#settings").style.display = "block";
    $$(".hk").forEach((inp) => (inp.value = hotkeys[inp.dataset.action] || ""));
    $("#cursorColorInput").value = cursorColor;
  };
  $("#settingsClose").onclick = () => {
    $("#settings").style.display = "none";
    saveSettings();
    renderHint();
  };
  $$(".hk").forEach((inp) => {
    inp.oninput = () => {
      hotkeys[inp.dataset.action] = inp.value;
      saveSettings();
      renderHint();
    };
  });
  $("#cursorColorInput").oninput = (e) => {
    cursorColor = e.target.value;
    updateSelPattern();
    saveSettings();
    sendPresence();
    requestRender();
  };
  imageLoader.onchange = (e) => {
    const file = e.target.files[0];
    handleImageFile(file);
    e.target.value = "";
    e.target.blur();
  };
  document.addEventListener("paste", async (e) => {
    const item = [...(e.clipboardData?.items || [])].find(
      (it) => it.type.startsWith("image/"),
    );
    if (item) {
      const file = item.getAsFile();
      if (file) handleImageFile(file);
    }
  });
  window.addEventListener("dragover", (e) => {
    e.preventDefault();
  });
  window.addEventListener("drop", async (e) => {
    e.preventDefault();
    const f = [...e.dataTransfer.files].find((f) => f.type.startsWith("image/"));
    if (f) handleImageFile(f);
  });

  document.addEventListener("keydown", (e) => {
    if (!app.ready) return;
    if (app.importActive) return;
    if (e.target.tagName === "INPUT") return;
    const k = e.key;
    if (k === hotkeys.draw) setTool("draw");
    else if (k === hotkeys.erase) setTool("erase");
    else if (k === hotkeys.select) setTool("select");
    else if (k === hotkeys.fill) setTool("fill");
    else if (k === hotkeys.size2) setSize(2);
    else if (k === hotkeys.size6) setSize(6);
    else if (k === hotkeys.size12) setSize(12);
    else if (k === hotkeys.size24) setSize(24);
  });

  // ===== lobby / rooms =====
  async function getSignalURL() {
    try {
      const r = await fetch("config.json", { cache: "no-store" });
      if (!r.ok) throw new Error(`config.json HTTP ${r.status}`);
      const j = await r.json();
      console.info("[signal] config.json =", j);
      return j.SIGNAL_URL;
    } catch (e) {
      console.error("[signal] failed to read config.json:", e);
      alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å config.json. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–µ–ø–ª–æ–π –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ñ–∞–π–ª–∞.");
      throw e;
    }
  }

  function normalizeWS(u) {
    try {
      const url = new URL(u, location.href);
      if (location.protocol === "https:" && url.protocol === "ws:") {
        url.protocol = "wss:";
      }
      return url.toString();
    } catch {
      return u;
    }
  }

  async function fetchRooms() {
    try {
      const raw = await getSignalURL();
      const url = normalizeWS(raw);
      return await new Promise((res) => {
        const ws = new WebSocket(url);
        let opened = false;
        const t = setTimeout(() => {
          try {
            ws.close();
          } catch {}
          res([]);
        }, 2000);
        ws.onopen = () => {
          opened = true;
          console.info("[signal] WS open:", url);
          ws.send(JSON.stringify({ type: "list" }));
        };
        ws.onmessage = (e) => {
          const m = JSON.parse(e.data);
          if (m.type === "rooms") {
            clearTimeout(t);
            ws.close();
            res(m.rooms || []);
          }
        };
        ws.onerror = (ev) => {
          console.error("[signal] WS error", ev);
          clearTimeout(t);
          if (!opened) {
            alert("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–∏–≥–Ω–∞–ª-—Å–µ—Ä–≤–µ—Ä—É –Ω–µ —É–¥–∞–ª–æ—Å—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ CSP –∏ —á—Ç–æ URL –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å wss://");
          }
          res([]);
        };
        ws.onclose = (ev) => {
          console.warn("[signal] WS closed", ev.code, ev.reason);
        };
      });
    } catch (e) {
      console.error("[signal] fetchRooms failed", e);
      return [];
    }
  }

  function getHiddenRooms() {
    try {
      return JSON.parse(localStorage.getItem("hiddenRooms")) || [];
    } catch {
      return [];
    }
  }
  function hideRoom(id) {
    const h = getHiddenRooms();
    if (!h.includes(id)) h.push(id);
    try {
      localStorage.setItem("hiddenRooms", JSON.stringify(h));
    } catch {}
    renderRooms();
  }

  async function renderRooms() {
    const list = await fetchRooms();
    const holder = $("#rooms");
    holder.innerHTML = "";
    const hidden = getHiddenRooms();
    list.forEach((r) => {
      if (hidden.includes(r.id)) return;
      const card = document.createElement("div");
      card.className = "room";
      card.textContent = `${r.id} (${r.users})`;
      card.onclick = () => joinRoom(r.id);
      const del = document.createElement("button");
      del.className = "hide";
      del.textContent = "üóë";
      del.onclick = (e) => {
        e.stopPropagation();
        hideRoom(r.id);
      };
      card.appendChild(del);
      holder.appendChild(card);
    });
  }
  $("#refresh").onclick = renderRooms;
  renderRooms();

  $("#create").onclick = async () => {
    const rid =
      $("#room").value.trim() ||
      `room-${Math.random().toString(36).slice(2, 6)}`;
    $("#room").value = rid;
    // —è –≤–µ—à—É —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞ —è–≤–Ω—ã–π –≤—ã–∑–æ–≤ create (—Ä–µ–µ—Å—Ç—Ä –Ω–∞ —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–µ)
    const url = normalizeWS(await getSignalURL());
    const ws = new WebSocket(url);
    let opened = false;
    ws.onopen = () => {
      opened = true;
      console.info("[signal] WS open:", url);
      ws.send(JSON.stringify({ type: "create", roomId: rid }));
    };
    ws.onerror = (ev) => {
      console.error("[signal] WS error", ev);
      if (!opened) {
        alert("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–∏–≥–Ω–∞–ª-—Å–µ—Ä–≤–µ—Ä—É –Ω–µ —É–¥–∞–ª–æ—Å—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ CSP –∏ —á—Ç–æ URL –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å wss://");
      }
    };
    ws.onclose = (ev) => {
      console.warn("[signal] WS closed", ev.code, ev.reason);
    };
    ws.onmessage = (e) => {
      const m = JSON.parse(e.data);
      if (m.type === "created") {
        alert("–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞");
        ws.close();
        renderRooms();
      }
    };
  };

  async function joinRoom(id) {
    setRev(0);
    roomId = id;
    lastPull = 0;
    if (pullTimer) {
      clearTimeout(pullTimer);
      pullTimer = null;
    }
    const signalURL = normalizeWS(await getSignalURL());
    lobbyToStage();
    Net.connect(roomId, {
      onJoined: ({ me, roomId, peers }) => {
        meId = me; // —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–æ–π id
        cursorsMeta.set(me, { color: cursorColor });
        sendPresence();
        Net.requestState(); // —Å–µ—Ä–≤–µ—Ä–Ω—ã–π —Å–Ω–∞–ø—à–æ—Ç
        setTimeout(() => {
          if (strokes.size === 0) loadLocal();
        }, 1000);
        startPing();
      },
      onPeerOpen: (peerId) => {
        // –ø–æ–ø—Ä–æ—Å–∏—Ç—å —Å–Ω–∞–ø—à–æ—Ç –∞–¥—Ä–µ—Å–Ω–æ –∏ —É–∫–∞–∑–∞—Ç—å –∫—Ç–æ –ø—Ä–æ—Å–∏—Ç
        Net.sendReliableTo(peerId, { type: "state_req", id: meId });
        sendPresence();
      },
      onState: (state) => {
        if (state) mergeState(state, { fromServer: true });
      },
      onMsg: handleMsg,
      onCursor: ({ id, x, y, drawing }) => {
        cursors.set(id, { x, y, drawing, ts: Date.now() });
        requestRender();
      },
      onPong: (t) => {
        if (latencyBadge.hidden) return;
        const rtt = Math.max(0, Math.round(performance.now() - t));
        const newText = rtt + " ms";
        if (latencyBadge.textContent !== newText)
          latencyBadge.textContent = newText;
      },
      onClose: () => stopPing(),
    }, signalURL);
  }
  $("#join").onclick = () => joinRoom($("#room").value.trim() || "public-room");

  function lobbyToStage() {
    document.getElementById("lobby").style.display = "none";
    document.getElementById("stage").style.display = "block";
    document.body.classList.add("in-stage");
    document.getElementById("toolbar").dataset.show = "1";
    resize();
    adjustBottomInset();
  }

  // ===== drawing =====
  let isDown = false,
    lastMove = null,
    current = null;
  const cursors = new Map();
  const cursorsMeta = new Map();
  const touches = new Map();
  let pinchStart = null;
  let lastCursor = { x: 0, y: 0, t: 0 };
  let netFlushTimer = null;
  function maybeSendCursor(pos, drawing) {
    const now = performance.now();
    if (now - lastCursor.t < 16) return;
    const dxw = Math.abs(pos.x - lastCursor.x);
    const dyw = Math.abs(pos.y - lastCursor.y);
    const pxThreshold = 0.75;
    if (dxw * app.camera.scale < pxThreshold && dyw * app.camera.scale < pxThreshold)
      return;
    lastCursor = { x: pos.x, y: pos.y, t: now };
    if (Net.canSendLow()) Net.sendCursor({ x: pos.x, y: pos.y, drawing });
  }

  function armNetFlush() {
    if (netFlushTimer) return;
    netFlushTimer = setInterval(() => {
      if (
        current &&
        current.netPts &&
        current.netPts.length >= 64 &&
        !Net.canSendLow()
      ) {
        enqueue({
          type: "stroke_pts",
          id: current.id,
          by: meId,
          mode: current.mode,
          tool: current.mode,
          color: current.color,
          size: current.size,
          points: current.netPts.slice(),
        });
        current.netPts.length = 0;
      }
    }, 200);
  }
  function disarmNetFlush() {
    if (netFlushTimer) {
      clearInterval(netFlushTimer);
      netFlushTimer = null;
    }
  }

  function getTouchState() {
    const pts = [...touches.values()];
    const center = {
      x: (pts[0].x + pts[1].x) / 2,
      y: (pts[0].y + pts[1].y) / 2,
    };
    const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    return { center, dist };
  }

  function onPointerDown(e) {
    if (!app.ready) return;
    if (pendingImage) {
      // –¥–µ—Ä–∂–∏–º drag, –¥–∞–∂–µ –µ—Å–ª–∏ –∫—É—Ä—Å–æ—Ä —É—à—ë–ª –∑–∞ –∫–∞–Ω–≤–∞—Å
      try { app.cvs.setPointerCapture?.(e.pointerId); } catch {}
      const w = toWorld(e);
      previewDrag = { dx: w.x - pendingImage.x, dy: w.y - pendingImage.y };
      return;
    }
    if (app.importActive) return;
    app.cvs.setPointerCapture(e.pointerId);
    if (e.pointerType === "touch") {
      touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (touches.size === 2) {
        if (pendingImage) {
          imgPinch = { ...getTouchState(), scale: pendingImage.scale };
          return;
        }
        pinchStart = { camera: { ...app.camera }, ...getTouchState() };
        if (current) {
          strokes.delete(current.id);
          cache.delete(current.id);
          myStack.pop();
          deleted.add(current.id);
          enqueue({ type: "del", id: current.id });
          requestRender();
        }
        isDown = false;
        current = null;
        return;
      }
    }
    isDown = true;
    if (mode === "pipette") {
      const w = toWorld(e);
      const x = Math.round((w.x - app.camera.x) * app.camera.scale * app.DPR);
      const y = Math.round((w.y - app.camera.y) * app.camera.scale * app.DPR);
      const d = app.ctx.getImageData(x, y, 1, 1).data;
      const c =
        "#" +
        ((1 << 24) + (d[0] << 16) + (d[1] << 8) + d[2]).toString(16).slice(1);
      setColor(c, $("#color"));
      setTool("draw");
      isDown = false;
      return;
    }
    // ‚ñ∂ –ó–ê–õ–ò–í–ö–ê: –∫–ª–∏–∫–æ–º –∑–∞–ø—É—Å–∫–∞–µ–º flood-fill –∏ –≤—ã—Ö–æ–¥–∏–º
    if (mode === "fill") {
      const w = toWorld(e);
      performFill(w);
      isDown = false;
      return;
    }
    if (e.button === 1) {
      lastMove = { x: e.clientX, y: e.clientY };
      return;
    }
    const w = toWorld(e);
    if (mode === "select") {
      if (selection) {
        const r = selection.rect;
        const hit = pointInRect(w, r);
        const corner = hitCorner(w, r, 10 / app.camera.scale);
        if (corner) {
          selOp = {
            type: "resize",
            corner,
            start: w,
            rect: { ...r },
            orig: new Map(),
            path: selection.path.map((p) => ({ ...p })),
          };
          for (const id of selection.ids)
            selOp.orig.set(id, cloneStroke(strokes.get(id)));
        } else if (hit) {
          selOp = {
            type: "move",
            start: w,
            rect: { ...r },
            orig: new Map(),
            path: selection.path.map((p) => ({ ...p })),
          };
          for (const id of selection.ids)
            selOp.orig.set(id, cloneStroke(strokes.get(id)));
        } else {
          selection = null;
          ensureSelAnim(false);
          selOp = { type: "select", points: [w] };
        }
      } else {
        selOp = { type: "select", points: [w] };
      }
      selectionPreview = null;
      return;
    }
    current = {
      id: genId(),
      by: meId,
      mode,
      color: mode === "erase" ? undefined : brush.color,
      size: brush.size,
      points: [w],
      netPts: [],
    };
    strokes.set(current.id, current);
    cache.set(current.id, current);
    deleted.delete(current.id);
    myStack.push(current.id);
    redoStack.length = 0;
    enqueue({
      type: "stroke_pts",
      id: current.id,
      by: meId,
      mode: current.mode,
      tool: current.mode,
      color: current.color,
      size: current.size,
      points: [w],
    });
    armNetFlush();
    requestRender();
  }

  function onPointerMove(e) {
    if (!app.ready) return;
    if (pendingImage) {
      if (e.pointerType === "touch" && touches.has(e.pointerId)) {
        touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (touches.size === 2 && imgPinch) {
          const { dist } = getTouchState();
          pendingImage.scale = clamp(imgPinch.scale * (dist / imgPinch.dist), 0.05, 16);
          pendingImage.w = pendingImage.img.width * pendingImage.scale;
          pendingImage.h = pendingImage.img.height * pendingImage.scale;
          requestRender();
          return;
        }
      }
      const w = toWorld(e);
      if (previewDrag) {
        pendingImage.x = w.x - previewDrag.dx;
        pendingImage.y = w.y - previewDrag.dy;
      } else {
        pendingImage.x = w.x - pendingImage.w / 2;
        pendingImage.y = w.y - pendingImage.h / 2;
      }
      requestRender();
      return;
    }
    if (app.importActive) return;
    if (e.pointerType === "touch" && touches.has(e.pointerId)) {
      touches.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (touches.size === 2 && pinchStart) {
        const { center, dist } = getTouchState();
        const before = screenToWorld(
          pinchStart.center.x,
          pinchStart.center.y,
          pinchStart.camera,
        );
        app.camera.scale = clamp(
          pinchStart.camera.scale * (dist / pinchStart.dist),
          0.1,
          8,
        );
        const after = screenToWorld(center.x, center.y);
        app.camera.x += before.x - after.x;
        app.camera.y += before.y - after.y;
        drawGrid();
        requestRender();
        return;
      }
      if (touches.size > 1) return;
    }
    const w = toWorld(e);
    if ((e.buttons & 4) === 4) {
      if (lastMove) {
        app.camera.x -= (e.clientX - lastMove.x) / app.camera.scale;
        app.camera.y -= (e.clientY - lastMove.y) / app.camera.scale;
        drawGrid();
        requestRender();
      }
      lastMove = { x: e.clientX, y: e.clientY };
      return;
    }
    if (mode === "select" && isDown && selOp) {
      if (selOp.type === "select") {
        selOp.points.push(w);
        selectionPreview = selOp.points.slice();
      }
      if (selOp.type === "move") {
        const dx = w.x - selOp.start.x,
          dy = w.y - selOp.start.y;
        selection.rect = {
          x: selOp.rect.x + dx,
          y: selOp.rect.y + dy,
          w: selOp.rect.w,
          h: selOp.rect.h,
        };
        selection.path = selOp.path.map((p) => ({ x: p.x + dx, y: p.y + dy }));
        for (const id of selection.ids) {
          const o = selOp.orig.get(id);
          const s = strokes.get(id);
          if (s.mode === "image") {
            s.x = o.x + dx;
            s.y = o.y + dy;
          } else if (s.mode === "raster") {
            s.runs = o.runs.map((r) => {
              const y = Math.round(r.y + dy);
              const x0 = Math.round(r.x0 + dx);
              const x1 = Math.round(r.x1 + dx);
              return { y, x0, x1, color: r.color };
            });
            s.rowH = o.rowH ?? 1;
            updateRasterBBox(s);
          } else {
            s.points = o.points.map((p) => ({ x: p.x + dx, y: p.y + dy }));
          }
        }
      }
      if (selOp.type === "resize") {
        const r = selOp.rect;
        let x1 = r.x,
          y1 = r.y,
          x2 = r.x + r.w,
          y2 = r.y + r.h;
        if (selOp.corner.includes("l")) x1 = w.x;
        if (selOp.corner.includes("r")) x2 = w.x;
        if (selOp.corner.includes("t")) y1 = w.y;
        if (selOp.corner.includes("b")) y2 = w.y;
        const rect = {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          w: Math.abs(x2 - x1),
          h: Math.abs(y2 - y1),
        };
        selection.rect = rect;
        const sx = r.w ? rect.w / r.w : 1,
          sy = r.h ? rect.h / r.h : 1;
        const ox = r.x,
          oy = r.y;
        selection.path = selOp.path.map((p) => ({
          x: rect.x + (p.x - ox) * sx,
          y: rect.y + (p.y - oy) * sy,
        }));
        for (const id of selection.ids) {
          const o = selOp.orig.get(id);
          const s = strokes.get(id);
          if (s.mode === "image") {
            s.x = rect.x + (o.x - ox) * sx;
            s.y = rect.y + (o.y - oy) * sy;
            s.w = o.w * sx;
            s.h = o.h * sy;
          } else if (s.mode === "raster") {
            s.runs = o.runs.map((r) => {
              const y = Math.round(rect.y + (r.y - oy) * sy);
              const x0 = Math.round(rect.x + (r.x0 - ox) * sx);
              const x1 = Math.round(rect.x + (r.x1 - ox) * sx);
              return { y, x0, x1, color: r.color };
            });
            s.rowH = (o.rowH ?? 1) * sy;
            updateRasterBBox(s);
          } else {
            s.points = o.points.map((p) => ({
              x: rect.x + (p.x - ox) * sx,
              y: rect.y + (p.y - oy) * sy,
            }));
          }
        }
      }
      requestRender();
      maybeSendCursor(w, false);
      return;
    }
    if (isDown && current && (mode === "draw" || mode === "erase")) {
      const lp = current.points[current.points.length - 1];
      const dx = (w.x - lp.x) * app.camera.scale;
      const dy = (w.y - lp.y) * app.camera.scale;
      if (dx * dx + dy * dy >= 0.25) {
        current.points.push(w);
        // –≤—Å–µ–≥–¥–∞ –∫–æ–ø–∏–º –ª–æ–∫–∞–ª—å–Ω–æ
        current.netPts.push(w);
        // –∞ —á–∞–Ω–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ low-–∫–∞–Ω–∞–ª –Ω–µ –Ω–∞ –ø–∞—É–∑–µ
        if (current.netPts.length >= 64 && Net.canSendLow()) {
          enqueue({
            type: "stroke_pts",
            id: current.id,
            by: meId,
            mode: current.mode,
            tool: current.mode,
            color: current.color,
            size: current.size,
            points: current.netPts.slice(),
          });
          current.netPts.length = 0;
        }
      }
      requestRender();
    }
    if (mode === "erase" && isDown) {
      const rad = brush.size / 2;
      let changed = false;
      for (const [id, s] of strokes) {
        if (s === current) continue;
        if (s.mode === "raster") {
          if (!s._bbox) updateRasterBBox(s);
          if (!circleIntersectsBBox(w.x, w.y, rad, s._bbox)) continue;
          eraseRasterStroke(s, w.x, w.y, rad);
          rasterDirty.add(s.id);
          changed = true;
        }
      }
      if (changed) {
        requestRender();
      }
    }
    maybeSendCursor(w, isDown);
  }

  function onPointerUp(e) {
    try { app.cvs.releasePointerCapture?.(e.pointerId); } catch {}
    if (!app.ready) return;
    if (pendingImage) {
      if (e.pointerType === "touch") {
        touches.delete(e.pointerId);
        if (touches.size < 2) imgPinch = null;
      }
      previewDrag = null;
      return;
    }
    if (app.importActive) return;
    // –≥–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
    document.onkeydown = null;
    if (e.pointerType === "touch") {
      touches.delete(e.pointerId);
      if (pinchStart) {
        if (touches.size < 2) pinchStart = null;
        isDown = false;
        current = null;
        lastMove = null;
        return;
      }
    }
    isDown = false;
    lastMove = null;
    disarmNetFlush();
    if (current && current.netPts && current.netPts.length) {
      enqueue({
        type: "stroke_pts",
        id: current.id,
        by: meId,
        mode: current.mode,
        tool: current.mode,
        color: current.color,
        size: current.size,
        points: current.netPts.slice(),
      });
      current.netPts.length = 0;
    }
    if (mode === "select" && selOp) {
      if (selOp.type === "select" && selOp.points) {
        const poly = selOp.points;
        const rect = bboxOfPoints(poly);
        selection = { ids: [], path: poly, rect };
        for (const [id, s] of strokes) {
          if (strokeIntersectsPoly(s, poly)) selection.ids.push(id);
        }
        if (selection.ids.length === 0) selection = null;
      } else if (selOp.type === "move" || selOp.type === "resize") {
        if (selection)
          for (const id of selection.ids) {
            const s = strokes.get(id);
            Net.sendReliable({ type: "del", id });
            const payload = { ...s };
            if (payload._bbox) delete payload._bbox;
            Net.sendReliable({ type: "add", stroke: payload });
          }
      }
      ensureSelAnim(!!selection);
      selOp = null;
      selectionPreview = null;
      requestRender();
      debounceSave();
      current = null;
      return;
    }
    current = null;
    if (rasterDirty.size) {
      const ops = [];
      for (const id of rasterDirty) {
        const s = strokes.get(id);
        if (!s) continue;
        compactRuns(s);
        ops.push({ type: "del", id });
        if (s.runs.length) {
          const payload = { ...s };
          if (payload._bbox) delete payload._bbox;
          ops.push({ type: "add", stroke: payload });
        } else {
          strokes.delete(id);
        }
      }
      Net.sendReliable({ type: "batch", ops });
      rasterDirty.clear();
      debounceSave();
    }
  }

  // –ù–∞–≤–µ—à–∏–≤–∞–µ–º —Ö–æ—Ç–∫–µ–∏, –ø–æ–∫–∞ –µ—Å—Ç—å pendingImage
  function setPreviewHotkeys(on) {
    document.onkeydown = on
      ? (ev) => {
          if (ev.key === "Enter") {
            placeImagePreview();
            ev.preventDefault();
          }
          if (ev.key === "Escape") {
            cancelImagePreview();
            ev.preventDefault();
          }
        }
      : null;
  }

  function onPointerCancel(e) {
    try { app.cvs.releasePointerCapture?.(e.pointerId); } catch {}
    if (!app.ready) return;
    // –µ—Å–ª–∏ –±—ã–ª –∞–∫—Ç–∏–≤–Ω—ã–π —à—Ç—Ä–∏—Ö ‚Äî –¥–æ—Å—ã–ª–∞–µ–º –±—É—Ñ–µ—Ä
    if (current && current.netPts && current.netPts.length) {
      enqueue({
        type: "stroke_pts",
        id: current.id,
        by: meId,
        mode: current.mode,
        tool: current.mode,
        color: current.color,
        size: current.size,
        points: current.netPts.slice(),
      });
      current.netPts.length = 0;
    }
    disarmNetFlush();
    if (pendingImage) {
      touches.delete(e.pointerId);
      imgPinch = null;
      previewDrag = null;
      return;
    }
    if (app.importActive) return;
    touches.delete(e.pointerId);
    pinchStart = null;
  }

  // –∑—É–º/–ø–∞–Ω –∫–æ–ª–µ—Å–æ–º
  function onWheel(e) {
    if (!app.ready) return;
    if (pendingImage) {
      e.preventDefault();
      const k = Math.pow(1.0015, -e.deltaY);
      pendingImage.scale = clamp(pendingImage.scale * k, 0.05, 16);
      pendingImage.w = pendingImage.img.width * pendingImage.scale;
      pendingImage.h = pendingImage.img.height * pendingImage.scale;
      requestRender();
      return;
    }
    if (app.importActive) return;
    e.preventDefault();
    const mouse = { clientX: e.clientX, clientY: e.clientY };
    if (e.shiftKey) {
      app.camera.x -= e.deltaX / app.camera.scale;
      app.camera.y -= e.deltaY / app.camera.scale;
      drawGrid();
      requestRender();
      return;
    }
    const before = toWorld(mouse);
    const k = Math.pow(1.0015, -e.deltaY);
    app.camera.scale = clamp(app.camera.scale * k, 0.1, 8);
    const after = toWorld(mouse);
    app.camera.x += before.x - after.x;
    app.camera.y += before.y - after.y;
    drawGrid();
    requestRender();
  }

  addEventListener("keydown", (e) => {
    if (!app.ready) return;
    if (app.importActive) return;
    if (e.key === "Delete" && selection) {
      for (const id of selection.ids) {
        strokes.delete(id);
        deleted.add(id);
        Net.sendReliable({ type: "del", id });
      }
      selection = null;
      ensureSelAnim(false);
      requestRender();
      debounceSave();
    }
  });

  function toWorld(e) {
    return {
      x: e.clientX / app.camera.scale + app.camera.x,
      y: e.clientY / app.camera.scale + app.camera.y,
    };
  }
  function screenToWorld(x, y, cam = app.camera) {
    return { x: x / cam.scale + cam.x, y: y / cam.scale + cam.y };
  }
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  function rectFromPoints(a, b) {
    return {
      x: Math.min(a.x, b.x),
      y: Math.min(a.y, b.y),
      w: Math.abs(a.x - b.x),
      h: Math.abs(a.y - b.y),
    };
  }
  function pointInRect(p, r) {
    return p.x >= r.x && p.y >= r.y && p.x <= r.x + r.w && p.y <= r.y + r.h;
  }
  function rectsIntersect(a, b) {
    return !(
      a.x + a.w < b.x ||
      b.x + b.w < a.x ||
      a.y + a.h < b.y ||
      b.y + b.h < a.y
    );
  }
  function hitCorner(p, r, t) {
    const x1 = r.x,
      y1 = r.y,
      x2 = r.x + r.w,
      y2 = r.y + r.h;
    if (Math.abs(p.x - x1) <= t && Math.abs(p.y - y1) <= t) return "tl";
    if (Math.abs(p.x - x2) <= t && Math.abs(p.y - y1) <= t) return "tr";
    if (Math.abs(p.x - x1) <= t && Math.abs(p.y - y2) <= t) return "bl";
    if (Math.abs(p.x - x2) <= t && Math.abs(p.y - y2) <= t) return "br";
    return null;
  }
  function bboxOfPoints(pts) {
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const p of pts) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }
  function pointInPoly(p, poly) {
    let inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const xi = poly[i].x,
        yi = poly[i].y,
        xj = poly[j].x,
        yj = poly[j].y;
      const intersect =
        yi > p.y != yj > p.y && p.x < ((xj - xi) * (p.y - yi)) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function polyIntersectsRect(poly, rx, ry, rw, rh) {
    const pb = bboxOfPoints(poly);
    if (pb.x > rx + rw || pb.x + pb.w < rx || pb.y > ry + rh || pb.y + pb.h < ry)
      return false;
    const rectPts = [
      { x: rx, y: ry },
      { x: rx + rw, y: ry },
      { x: rx, y: ry + rh },
      { x: rx + rw, y: ry + rh },
    ];
    if (rectPts.some((p) => pointInPoly(p, poly))) return true;
    const inRect = (p) => p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh;
    if (poly.some(inRect)) return true;
    const segInt = (a, b, c, d) => {
      const s1x = b.x - a.x,
        s1y = b.y - a.y,
        s2x = d.x - c.x,
        s2y = d.y - c.y;
      const s = (-s1y * (a.x - c.x) + s1x * (a.y - c.y)) / (-s2x * s1y + s1x * s2y);
      const t = (s2x * (a.y - c.y) - s2y * (a.x - c.x)) / (-s2x * s1y + s1x * s2y);
      return s >= 0 && s <= 1 && t >= 0 && t <= 1;
    };
    const rectEdges = [
      [rectPts[0], rectPts[1]],
      [rectPts[1], rectPts[3]],
      [rectPts[3], rectPts[2]],
      [rectPts[2], rectPts[0]],
    ];
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      const e1 = [poly[j], poly[i]];
      if (rectEdges.some((e2) => segInt(e1[0], e1[1], e2[0], e2[1]))) return true;
    }
    return false;
  }
  function strokeIntersectsPoly(s, poly) {
    if (s.mode === "image") {
      const pts = [
        { x: s.x, y: s.y },
        { x: s.x + s.w, y: s.y },
        { x: s.x, y: s.y + s.h },
        { x: s.x + s.w, y: s.y + s.h },
      ];
      return pts.some((pt) => pointInPoly(pt, poly));
    }
    if (s.mode === "raster") {
      if (!s.runs.length) return false;
      if (!s._bbox) updateRasterBBox(s);
      const { x, y, w, h } = s._bbox;
      return polyIntersectsRect(poly, x, y, w, h);
    }
    return s.points.some((pt) => pointInPoly(pt, poly));
  }
  function cloneStroke(s) {
    if (s.mode === "image") return { ...s };
    if (s.mode === "raster")
      return { ...s, runs: s.runs.map((r) => ({ ...r })) };
    return { ...s, points: s.points.map((p) => ({ ...p })) };
  }
  function bboxOfStroke(s) {
    if (s.mode === "image") {
      return { x: s.x, y: s.y, w: s.w, h: s.h };
    }
    if (s.mode === "raster") {
      if (s._bbox) return { ...s._bbox };
      if (!s.runs.length) return { x: 0, y: 0, w: 0, h: 0 };
      updateRasterBBox(s);
      return { ...s._bbox };
    }
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const p of s.points) {
      if (p.x < minX) minX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.x > maxX) maxX = p.x;
      if (p.y > maxY) maxY = p.y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }
  function hexToRgb(hex) {
    const n = parseInt(hex.slice(1), 16);
    return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
  }

  function eraseRasterStroke(s, cx, cy, rad) {
    const out = [];
    const r2 = rad * rad;
    const rh = s.rowH ?? 1;
    for (const run of s.runs) {
      const top = run.y;
      const bottom = run.y + rh;
      let dy = 0;
      if (cy < top) dy = top - cy;
      else if (cy > bottom) dy = cy - bottom;
      if (dy > rad) {
        out.push(run);
        continue;
      }
      const dx = Math.sqrt(r2 - dy * dy);
      const cutL = Math.floor(cx - dx);
      const cutR = Math.ceil(cx + dx);
      if (run.x1 < cutL || run.x0 > cutR) {
        out.push(run);
        continue;
      }
      if (run.x0 < cutL) {
        const l = { y: run.y, x0: run.x0, x1: cutL - 1, color: run.color };
        if (l.x0 <= l.x1) out.push(l);
      }
      if (run.x1 > cutR) {
        const r = { y: run.y, x0: cutR + 1, x1: run.x1, color: run.color };
        if (r.x0 <= r.x1) out.push(r);
      }
    }
    s.runs = out;
  }

  function updateRasterBBox(s) {
    const rh = s.rowH ?? 1;
    let minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;
    for (const r of s.runs) {
      if (r.x0 < minX) minX = r.x0;
      if (r.y < minY) minY = r.y;
      if (r.x1 > maxX) maxX = r.x1;
      if (r.y + rh > maxY) maxY = r.y + rh;
    }
    s._bbox =
      minX === Infinity
        ? { x: 0, y: 0, w: 0, h: 0 }
        : { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY };
  }

  function circleIntersectsBBox(cx, cy, r, b) {
    const dx = Math.max(b.x - cx, 0, cx - (b.x + b.w));
    const dy = Math.max(b.y - cy, 0, cy - (b.y + b.h));
    return dx * dx + dy * dy <= r * r;
  }

  function compactRuns(s) {
    s.runs.sort((a, b) => a.y - b.y || a.x0 - b.x0);
    const out = [];
    for (const r of s.runs) {
      const last = out[out.length - 1];
      if (last && last.y === r.y && last.color === r.color && last.x1 >= r.x0 - 1) {
        if (r.x1 > last.x1) last.x1 = r.x1;
      } else out.push(r);
    }
    s.runs = out;
    updateRasterBBox(s);
  }

  // === Deterministic flood-fill: convert to world-space raster runs ===
  function performFill(w) {
    const W = app.cvs.width, H = app.cvs.height;
    const snap = app.ctx.getImageData(0, 0, W, H);
    const data = snap.data;
    const x0 = Math.round((w.x - app.camera.x) * app.camera.scale * app.DPR);
    const y0 = Math.round((w.y - app.camera.y) * app.camera.scale * app.DPR);
    if (x0 < 0 || y0 < 0 || x0 >= W || y0 >= H) return;

    const i0 = (y0 * W + x0) * 4;
    const tgt = [data[i0], data[i0 + 1], data[i0 + 2], data[i0 + 3]];
    const tol = 24, atol = 32;
    const seen = new Uint8Array(W * H);
    const mask = new Uint8Array(W * H);
    const stack = [x0, y0];
    seen[y0 * W + x0] = 1;

    const pxOk = (i) =>
      Math.abs(data[i] - tgt[0]) <= tol &&
      Math.abs(data[i + 1] - tgt[1]) <= tol &&
      Math.abs(data[i + 2] - tgt[2]) <= tol &&
      Math.abs(data[i + 3] - tgt[3]) <= atol;

    while (stack.length) {
      const y = stack.pop();
      const x = stack.pop();
      let xl = x, xr = x;
      for (;;) {
        const il = (y * W + (xl - 1)) * 4;
        if (xl <= 0 || seen[y * W + (xl - 1)] || !pxOk(il)) break;
        xl--;
        seen[y * W + xl] = 1;
      }
      for (;;) {
        const ir = (y * W + (xr + 1)) * 4;
        if (xr >= W - 1 || seen[y * W + (xr + 1)] || !pxOk(ir)) break;
        xr++;
        seen[y * W + xr] = 1;
      }
      for (let xx = xl; xx <= xr; xx++) mask[y * W + xx] = 1;
      for (const ny of [y - 1, y + 1]) {
        if (ny < 0 || ny >= H) continue;
        let run = false;
        for (let xx = xl; xx <= xr; xx++) {
          const idx = ny * W + xx;
          if (!seen[idx]) {
            const ip = (ny * W + xx) * 4;
            if (pxOk(ip)) {
              seen[idx] = 1;
              if (!run) {
                stack.push(xx, ny);
                run = true;
              }
            } else if (run) run = false;
          } else if (run) run = false;
        }
      }
    }

    const runs = [];
    const inv = 1 / (app.camera.scale * app.DPR);
    const rowH = inv;
    for (let y = 0; y < H; y++) {
      let x = 0;
      while (x < W) {
        while (x < W && !mask[y * W + x]) x++;
        if (x >= W) break;
        const xStart = x;
        while (x < W && mask[y * W + x]) x++;
        const xEnd = x - 1;
        const wx0 = app.camera.x + xStart * inv;
        const wx1 = app.camera.x + (xEnd + 1) * inv;
        const wy = app.camera.y + y * inv;
        runs.push({ y: wy, x0: wx0, x1: wx1, color: brush.color });
      }
    }
    if (!runs.length) return;

    const id = genId();
    const stroke = { id, by: meId, mode: "raster", color: brush.color, runs, rowH };
    updateRasterBBox(stroke);
    strokes.set(id, stroke);
    cache.set(id, stroke);
    deleted.delete(id);
    myStack.push(id);
    const payload = { ...stroke };
    delete payload._bbox;
    Net.sendReliable({ type: "add", stroke: payload });
    requestRender();
    debounceSave();
  }

  function loadImageForStroke(s) {
    const img = new Image();
    img.onload = requestRender;
    img.src = s.data;
    Object.defineProperty(s, "_img", { value: img, enumerable: false });
  }

  // –±–∞—Ç—á–∏–Ω–≥ —Å–µ—Ç–µ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π
  const buffer = [];
  let flushTimer = null;
  function enqueue(op) {
    buffer.push(op);
    if (!flushTimer) {
      flushTimer = setTimeout(() => {
        Net.sendReliable({
          type: "batch",
          ops: buffer.splice(0, buffer.length),
        });
        flushTimer = null;
      }, 20);
    }
  }

  // –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä
  let rerender = false;
  function requestRender() {
    rerender = true;
  }
  function loop() {
    if (rerender) {
      draw();
      rerender = false;
    }
    requestAnimationFrame(loop);
  }
  function draw() {
    if (!app.ctx || !app.cvs) return;
    const vw = app.cvs.width / app.DPR,
      vh = app.cvs.height / app.DPR;
    app.ctx.clearRect(0, 0, vw, vh);
    for (const s of strokes.values()) {
      if (s.mode === "image") {
        if (s._img) {
          const prevSmooth = app.ctx.imageSmoothingEnabled;
          app.ctx.imageSmoothingEnabled = false;
          app.ctx.drawImage(
            s._img,
            (s.x - app.camera.x) * app.camera.scale,
            (s.y - app.camera.y) * app.camera.scale,
            s.w * app.camera.scale,
            s.h * app.camera.scale,
          );
          app.ctx.imageSmoothingEnabled = prevSmooth;
        }
        continue;
      }
      if (s.mode === "raster") {
        if (!s._bbox) updateRasterBBox(s);
        const scale = app.camera.scale;
        const vx1 = vw,
          vy1 = vh;
        const bx0 = (s._bbox.x - app.camera.x) * scale;
        const by0 = (s._bbox.y - app.camera.y) * scale;
        const bx1 = (s._bbox.x + s._bbox.w - app.camera.x) * scale;
        const by1 = (s._bbox.y + s._bbox.h - app.camera.y) * scale;
        if (bx1 < 0 || bx0 > vx1 || by1 < 0 || by0 > vy1) continue;
        let last = "";
        for (const r of s.runs) {
          if (r.color !== last) {
            app.ctx.fillStyle = r.color;
            last = r.color;
          }
          // –ª–µ–≤–∞—è/–≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã ‚Äî floor; –ø—Ä–∞–≤–∞—è/–Ω–∏–∂–Ω—è—è ‚Äî ceil —Å —É—á—ë—Ç–æ–º –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ü–∞
          const x0p = Math.floor((r.x0 - app.camera.x) * scale);
          const x1p = Math.ceil((r.x1 + 1 - app.camera.x) * scale);
          const y0p = Math.floor((r.y - app.camera.y) * scale);
          const y1p = Math.ceil((r.y + (s.rowH ?? 1) - app.camera.y) * scale);
          if (x1p < 0 || x0p > vx1 || y1p < 0 || y0p > vy1) continue;
          const rw = Math.max(1, x1p - x0p);
          const rh = Math.max(1, y1p - y0p);
          app.ctx.fillRect(x0p, y0p, rw, rh);
        }
        continue;
      }
      app.ctx.save();
      app.ctx.lineJoin = s.join || "round";
      app.ctx.lineCap = s.cap || "round";
      setCompositeForTool(app.ctx, s.mode);
      app.ctx.strokeStyle = s.mode === "erase" ? "#000000" : s.color;
      app.ctx.lineWidth = s.size * app.camera.scale;
      app.ctx.beginPath();
      s.points.forEach((p, i) => {
        const x = (p.x - app.camera.x) * app.camera.scale,
          y = (p.y - app.camera.y) * app.camera.scale;
        if (i === 0) app.ctx.moveTo(x, y);
        else app.ctx.lineTo(x, y);
      });
      app.ctx.stroke();
      app.ctx.restore();
    }
    if (pendingImage) {
      const p = pendingImage;
      const x = (p.x - app.camera.x) * app.camera.scale;
      const y = (p.y - app.camera.y) * app.camera.scale;
      const w = p.w * app.camera.scale;
      const h = p.h * app.camera.scale;
      app.ctx.save();
      app.ctx.globalAlpha = 0.5;
      app.ctx.drawImage(p.img, x, y, w, h);
      app.ctx.setLineDash([4, 4]);
      app.ctx.strokeStyle = "#888";
      app.ctx.strokeRect(x, y, w, h);
      app.ctx.restore();
    }
    if (selection) drawSel(selection.path, selection.rect, true);
    if (selectionPreview)
      drawSel(selectionPreview, bboxOfPoints(selectionPreview), false);
    // –∫—É—Ä—Å–æ—Ä—ã
    const now = Date.now();
    for (const [id, c] of cursors) {
      if (now - c.ts > 3000) continue;
      const x = (c.x - app.camera.x) * app.camera.scale;
      const y = (c.y - app.camera.y) * app.camera.scale;
      const col = cursorsMeta.get(id)?.color || "#007aff";
      drawPeerCursor(x, y, col);
    }
  }

  function drawSel(path, rect, handles) {
    app.ctx.save();
    app.ctx.beginPath();
    path.forEach((p, i) => {
      const x = (p.x - app.camera.x) * app.camera.scale,
        y = (p.y - app.camera.y) * app.camera.scale;
      if (i === 0) app.ctx.moveTo(x, y);
      else app.ctx.lineTo(x, y);
    });
    app.ctx.closePath();
    app.ctx.save();
    const t = (Date.now() / 150) % 8;
    app.ctx.translate(-t, -t);
    app.ctx.fillStyle = selPattern || "rgba(0,0,0,0.08)";
    app.ctx.fill();
    app.ctx.restore();
    app.ctx.strokeStyle = cursorColor;
    app.ctx.setLineDash([8, 4]);
    app.ctx.stroke();
    app.ctx.setLineDash([]);
    if (handles) {
      const x = (rect.x - app.camera.x) * app.camera.scale,
        y = (rect.y - app.camera.y) * app.camera.scale,
        w = rect.w * app.camera.scale,
        h = rect.h * app.camera.scale;
      const hs = 6;
      const corners = [
        [x, y],
        [x + w, y],
        [x, y + h],
        [x + w, y + h],
      ];
      app.ctx.fillStyle = "#fff";
      app.ctx.strokeStyle = cursorColor;
      for (const [cx, cy] of corners) {
        app.ctx.beginPath();
        app.ctx.rect(cx - hs / 2, cy - hs / 2, hs, hs);
        app.ctx.fill();
        app.ctx.stroke();
      }
    }
    app.ctx.restore();
  }

  function drawPeerCursor(x, y, color) {
    app.ctx.save();
    app.ctx.translate(x, y);
    app.ctx.rotate((-20 * Math.PI) / 180);
    app.ctx.scale(1.5, 1.5);
    app.ctx.lineJoin = "round";
    app.ctx.lineCap = "round";
    app.ctx.fillStyle = color;
    app.ctx.strokeStyle = color;
    app.ctx.shadowColor = "rgba(0,0,0,0.2)";
    app.ctx.shadowBlur = 2;
    const r = 4;
    app.ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = ((i * 72 - 90) * Math.PI) / 180;
      const x1 = Math.cos(a) * r;
      const y1 = Math.sin(a) * r;
      app.ctx.lineTo(x1, y1);
      const a2 = a + (36 * Math.PI) / 180;
      app.ctx.lineTo((Math.cos(a2) * r) / 2, (Math.sin(a2) * r) / 2);
    }
    app.ctx.closePath();
    app.ctx.fill();
    app.ctx.beginPath();
    app.ctx.moveTo(0, 0);
    app.ctx.lineTo(0, 10);
    app.ctx.stroke();
    app.ctx.restore();
  }

  // —Å–µ—Ç–µ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
  function handleMsg(op) {
    if (op.type === "batch") {
      for (const a of op.ops) handleMsg(a);
      return;
    }
    if (op.type === "stroke_pts") {
      let s = strokes.get(op.id);
      if (!s) {
        s = {
          id: op.id,
          by: op.by,
          mode: op.mode || op.tool,
          color: op.color,
          size: op.size,
          points: [],
        };
        strokes.set(op.id, s);
        cache.set(op.id, s);
        deleted.delete(op.id);
      }
      for (const p of op.points) s.points.push(p);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "presence") {
      cursorsMeta.set(op.id, { color: op.cursorColor || "#007aff" });
      return;
    }
    if (op.type === "del") {
      strokes.delete(op.id);
      deleted.add(op.id);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "add") {
      const s = op.stroke;
      if (s.mode === "image") loadImageForStroke(s);
      strokes.set(s.id, s);
      cache.set(s.id, s);
      deleted.delete(s.id);
      requestRender();
      debounceSave();
      return;
    }
    if (op.type === "state_req") {
      if (op.id) {
        Net.sendReliableTo(op.id, {
          type: "state_full",
          state: serializeState(),
        });
      } else {
        // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π (—Å—Ç–∞—Ä—ã–µ –∫–ª–∏–µ–Ω—Ç—ã) ‚Äî —à–∏—Ä–æ–∫–æ–≤–µ—â–∞—Ç–µ–ª—å–Ω–æ
        Net.sendReliable({
          type: "state_full",
          state: serializeState(),
        });
      }
      return;
    }
    if (op.type === "state_full") {
      if (op.state) mergeState(op.state);
      return;
    }
  }

  function mergeState(state, opt = {}) {
    try {
      let changed = false;
      if (state && typeof state.bg === "string") {
        app.bgColor = state.bg;
        drawGrid();
      }
      if (state && Array.isArray(state.strokes)) {
        for (const s of state.strokes) {
          if (s.mode === "raster") compactRuns(s);
          const had = strokes.get(s.id);
          if (!had) {
            if (s.mode === "image") loadImageForStroke(s);
            strokes.set(s.id, s);
            cache.set(s.id, s);
            deleted.delete(s.id);
            changed = true;
          } else if (
            s.mode === "image" ||
            s.mode === "raster" ||
            (had.points?.length || 0) < (s.points?.length || 0)
          ) {
            if (s.mode === "image" && had.mode === "image") {
              const sigHad = `${had.w}x${had.h}:${had.data?.length || 0}`;
              const sigNew = `${s.w}x${s.h}:${s.data?.length || 0}`;
              if (sigHad === sigNew) continue;
            }
            if (s.mode === "raster" && had.mode === "raster") {
              const sigHad = `${had.runs.length}:${had.rowH ?? 1}`;
              const sigNew = `${s.runs.length}:${s.rowH ?? 1}`;
              if (sigHad === sigNew) continue;
            }
            if (s.mode === "image") loadImageForStroke(s);
            strokes.set(s.id, s);
            cache.set(s.id, s);
            deleted.delete(s.id);
            changed = true;
          }
        }
      }
      if (state && Array.isArray(state.deleted)) {
        for (const id of state.deleted) {
          strokes.delete(id);
          deleted.add(id);
        }
        if (state.deleted.length) changed = true;
      }
      // –ø–æ–¥–Ω—è—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é —Ä–µ–≤–∏–∑–∏—é –¥–æ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π/—á—É–∂–æ–π
      const srvRev = state && typeof state.rev === "number" ? state.rev | 0 : 0;
      if (srvRev > rev) setRev(srvRev);
      requestRender();
      // –í–ê–ñ–ù–û:
      // - –µ—Å–ª–∏ —ç—Ç–æ —Å–µ—Ä–≤–µ—Ä–Ω—ã–π state ‚Üí –ù–ï —Å–æ—Ö—Ä–∞–Ω—è–µ–º (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø–µ—Ç–ª–∏)
      // - –µ—Å–ª–∏ —ç—Ç–æ peer state_full (opt.fromServer=false) –∏–ª–∏ –ª–æ–∫–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ ‚Üí —Å–æ—Ö—Ä–∞–Ω—è–µ–º
      if (!opt.fromServer && changed) debounceSave();
      return changed;
    } catch (e) {}
  }

  Object.assign(window, {
    strokes,
    cache,
    myStack,
    get meId() {
      return meId;
    },
    serializeState,
    mergeState,
    screenToWorld,
    requestRender,
    debounceSave,
    genId,
  });

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º—ã–µ, ¬´—Ç–æ–Ω–∫–∏–µ¬ª –ø–æ–ª—è
  function serializeState() {
    const out = [];
    for (const s of strokes.values()) {
      const copy = { ...s };
      delete copy._img;
      delete copy._bbox;
      out.push(copy);
    }
    return { bg: app.bgColor, strokes: out, rev, deleted: [...deleted] };
  }

  // undo/redo
  function undo() {
    const id = myStack.pop();
    if (!id) {
      sfx.beep(220, 0.05);
      return;
    }
    sfx.beep(660, 0.05);
    Net.sendReliable({ type: "del", id });
    strokes.delete(id);
    deleted.add(id);
    redoStack.push(id);
    requestRender();
    debounceSave();
  }
  function redo() {
    const id = redoStack.pop();
    if (!id) {
      sfx.beep(220, 0.05);
      return;
    }
    sfx.beep(660, 0.05);
    const s = cache.get(id);
    if (!s) return;
    strokes.set(id, s);
    deleted.delete(id);
    const payload = { ...s };
    if (payload._bbox) delete payload._bbox;
    Net.sendReliable({ type: "add", stroke: payload });
    myStack.push(id);
    requestRender();
    debounceSave();
  }

  // PNG —ç–∫—Å–ø–æ—Ä—Ç
  async function exportPNG() {
    if (strokes.size === 0) {
      alert("–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å");
      return;
    }
    const blob = await exportEmbeddedPNG();
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "canvas.png";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 0);
  }

  function leaveRoom() {
    Net.disconnect();
    stopPing();
    setRev(0);
    roomId = null;
    strokes.clear();
    cache.clear();
    myStack.length = 0;
    redoStack.length = 0;
    deleted.clear();
    selection = null;
    ensureSelAnim(false);
    if (pullTimer) {
      clearTimeout(pullTimer);
      pullTimer = null;
    }
    document.getElementById("stage").style.display = "none";
    document.getElementById("lobby").style.display = "block";
    document.body.classList.remove("in-stage");
    delete document.getElementById("toolbar").dataset.show;
    document.documentElement.style.setProperty("--stage-bottom-inset", "0px");
    resize();
    renderRooms();
  }

  // –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ü–∏—è + —Å–µ—Ä–≤–µ—Ä–Ω–∞—è
  function saveLocal() {
    try {
      localStorage.setItem("room:" + roomId, JSON.stringify(serializeState()));
    } catch {}
  }
  function loadLocal() {
    try {
      const j = localStorage.getItem("room:" + roomId);
      if (j) {
        const s = JSON.parse(j);
        if (s) mergeState(s);
      }
    } catch {}
  }
  let saveTimer = null;
  function debounceSave() {
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      saveTimer = null;
      setRev((rev | 0) + 1);
      saveLocal();
      Net.saveState(serializeState());
    }, 700);
  }

  let pullTimer = null,
    lastPull = 0;
  function schedulePull() {
    if (pullTimer) return;
    const now = Date.now();
    const wait = Math.max(0, 500 - (now - lastPull));
    pullTimer = setTimeout(() => {
      pullTimer = null;
      lastPull = Date.now();
      try {
        Net.requestState();
      } catch {}
    }, wait);
  }
  window.schedulePull = schedulePull;

  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      // –ø–æ–¥–Ω–∏–º–µ–º —Ä–µ–≤–∏–∑–∏—é –∏ —Å–æ—Ö—Ä–∞–Ω–∏–º
      setRev((rev | 0) + 1);
      Net.saveState(serializeState());
    }
  });

  window.addEventListener("beforeunload", () => {
    try {
      setRev((rev | 0) + 1);
      Net.saveState(serializeState());
    } catch {}
  });

  const sfx = (() => {
    let ctx = null, enabled = JSON.parse(localStorage.getItem("sfx") || "true");
    function beep(freq = 880, dur = 0.06, vol = 0.07) {
      if (!enabled) return;
      try {
        ctx ||= new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.frequency.value = freq;
        o.type = "sine";
        g.gain.value = 0;
        o.connect(g);
        g.connect(ctx.destination);
        const t = ctx.currentTime;
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
        o.start(t);
        o.stop(t + dur + 0.01);
      } catch {}
    }
    return {
      beep,
      set(v) {
        enabled = v;
        localStorage.setItem("sfx", JSON.stringify(!!v));
      },
    };
  })();
  document.getElementById("settings")?.insertAdjacentHTML(
    "beforeend",
    `<label class="row"><input id="opt-sfx" type="checkbox"> –ó–≤—É–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</label>`,
  );
  const sfxBox = document.getElementById("opt-sfx");
  if (sfxBox) {
    sfxBox.checked = JSON.parse(localStorage.getItem("sfx") || "true");
    sfxBox.onchange = () => sfx.set(sfxBox.checked);
  }
</script>
